// tslint:disable
/**
 * collect
 * Collect Web Application
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Alert
 */
export interface Alert {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Alert
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    period?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    _function?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    context?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    deadbandvalue?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    activationDelay?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    unit?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    FQTagName?: string;
    /**
     * 
     * @type {object}
     * @memberof Alert
     */
    metadata?: object;
    /**
     * 
     * @type {object}
     * @memberof Alert
     */
    alertinfo?: object;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    tagId?: string;
}
/**
 * 
 * @export
 * @interface AlertFields
 */
export interface AlertFields {
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    version?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    createdOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    updatedOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    id?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    name?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    type?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    period?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    _function?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    context?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    user?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    deadbandvalue?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    activationDelay?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    unit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    FQTagName?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    metadata?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    alertinfo?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertFields
     */
    tagId?: boolean;
}
/**
 * 
 * @export
 * @interface AlertFilter
 */
export interface AlertFilter {
    /**
     * 
     * @type {number}
     * @memberof AlertFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof AlertFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof AlertFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof AlertFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AlertFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {AlertFields}
     * @memberof AlertFilter
     */
    fields?: AlertFields;
    /**
     * 
     * @type {Array<AlertIncludeFilterItems>}
     * @memberof AlertFilter
     */
    include?: Array<AlertIncludeFilterItems>;
}
/**
 * 
 * @export
 * @interface AlertIncludeFilterItems
 */
export interface AlertIncludeFilterItems {
    /**
     * 
     * @type {string}
     * @memberof AlertIncludeFilterItems
     */
    relation?: string;
    /**
     * 
     * @type {AlertScopeFilter}
     * @memberof AlertIncludeFilterItems
     */
    scope?: AlertScopeFilter;
}
/**
 * (tsType: Partial<Alert>, schemaOptions: { partial: true })
 * @export
 * @interface AlertPartial
 */
export interface AlertPartial {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AlertPartial
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    period?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    _function?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    context?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    deadbandvalue?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    activationDelay?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    unit?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    FQTagName?: string;
    /**
     * 
     * @type {object}
     * @memberof AlertPartial
     */
    metadata?: object;
    /**
     * 
     * @type {object}
     * @memberof AlertPartial
     */
    alertinfo?: object;
    /**
     * 
     * @type {string}
     * @memberof AlertPartial
     */
    tagId?: string;
}
/**
 * 
 * @export
 * @interface AlertScopeFilter
 */
export interface AlertScopeFilter {
    /**
     * 
     * @type {number}
     * @memberof AlertScopeFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof AlertScopeFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof AlertScopeFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof AlertScopeFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AlertScopeFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AlertScopeFilter
     */
    fields?: { [key: string]: object; };
    /**
     * 
     * @type {Array<{ [key: string]: object; }>}
     * @memberof AlertScopeFilter
     */
    include?: Array<{ [key: string]: object; }>;
}
/**
 * (tsType: AlertWithRelations, schemaOptions: { includeRelations: true })
 * @export
 * @interface AlertWithRelations
 */
export interface AlertWithRelations {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AlertWithRelations
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    period?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    _function?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    context?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    deadbandvalue?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    activationDelay?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    unit?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    FQTagName?: string;
    /**
     * 
     * @type {object}
     * @memberof AlertWithRelations
     */
    metadata?: object;
    /**
     * 
     * @type {object}
     * @memberof AlertWithRelations
     */
    alertinfo?: object;
    /**
     * 
     * @type {string}
     * @memberof AlertWithRelations
     */
    tagId?: string;
    /**
     * 
     * @type {TagWithRelations}
     * @memberof AlertWithRelations
     */
    tag?: TagWithRelations;
    /**
     * 
     * @type {Array<NotificationWithRelations>}
     * @memberof AlertWithRelations
     */
    notifications?: Array<NotificationWithRelations>;
}
/**
 * 
 * @export
 * @interface Config
 */
export interface Config {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof Config
     */
    id: string;
}
/**
 * 
 * @export
 * @interface ConfigFields
 */
export interface ConfigFields {
    [key: string]: object | any;

    /**
     * 
     * @type {boolean}
     * @memberof ConfigFields
     */
    id?: boolean;
}
/**
 * 
 * @export
 * @interface ConfigFilter
 */
export interface ConfigFilter {
    /**
     * 
     * @type {number}
     * @memberof ConfigFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof ConfigFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof ConfigFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof ConfigFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ConfigFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {ConfigFields}
     * @memberof ConfigFilter
     */
    fields?: ConfigFields;
}
/**
 * (tsType: Partial<Config>, schemaOptions: { partial: true })
 * @export
 * @interface ConfigPartial
 */
export interface ConfigPartial {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof ConfigPartial
     */
    id?: string;
}
/**
 * (tsType: ConfigWithRelations, schemaOptions: { includeRelations: true })
 * @export
 * @interface ConfigWithRelations
 */
export interface ConfigWithRelations {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof ConfigWithRelations
     */
    id: string;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof Device
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    deviceTypeId?: string;
}
/**
 * 
 * @export
 * @interface DeviceFields
 */
export interface DeviceFields {
    [key: string]: object | any;

    /**
     * 
     * @type {boolean}
     * @memberof DeviceFields
     */
    version?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceFields
     */
    createdOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceFields
     */
    updatedOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceFields
     */
    id?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceFields
     */
    name?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceFields
     */
    type?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceFields
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceFields
     */
    deviceTypeId?: boolean;
}
/**
 * 
 * @export
 * @interface DeviceFilter
 */
export interface DeviceFilter {
    /**
     * 
     * @type {number}
     * @memberof DeviceFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof DeviceFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof DeviceFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {DeviceFields}
     * @memberof DeviceFilter
     */
    fields?: DeviceFields;
    /**
     * 
     * @type {Array<DeviceIncludeFilterItems>}
     * @memberof DeviceFilter
     */
    include?: Array<DeviceIncludeFilterItems>;
}
/**
 * 
 * @export
 * @interface DeviceIncludeFilterItems
 */
export interface DeviceIncludeFilterItems {
    /**
     * 
     * @type {string}
     * @memberof DeviceIncludeFilterItems
     */
    relation?: string;
    /**
     * 
     * @type {DeviceScopeFilter}
     * @memberof DeviceIncludeFilterItems
     */
    scope?: DeviceScopeFilter;
}
/**
 * (tsType: Partial<Device>, schemaOptions: { partial: true })
 * @export
 * @interface DevicePartial
 */
export interface DevicePartial {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof DevicePartial
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof DevicePartial
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof DevicePartial
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof DevicePartial
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DevicePartial
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof DevicePartial
     */
    type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DevicePartial
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DevicePartial
     */
    deviceTypeId?: string;
}
/**
 * 
 * @export
 * @interface DeviceScopeFilter
 */
export interface DeviceScopeFilter {
    /**
     * 
     * @type {number}
     * @memberof DeviceScopeFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceScopeFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceScopeFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof DeviceScopeFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof DeviceScopeFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof DeviceScopeFilter
     */
    fields?: { [key: string]: object; };
    /**
     * 
     * @type {Array<{ [key: string]: object; }>}
     * @memberof DeviceScopeFilter
     */
    include?: Array<{ [key: string]: object; }>;
}
/**
 * 
 * @export
 * @interface DeviceType
 */
export interface DeviceType {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    displayName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceType
     */
    sendIndividualUpdates?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceType
     */
    sendBatchUpdates?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof DeviceType
     */
    properties?: Array<object>;
}
/**
 * 
 * @export
 * @interface DeviceTypeFields
 */
export interface DeviceTypeFields {
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTypeFields
     */
    version?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTypeFields
     */
    createdOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTypeFields
     */
    updatedOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTypeFields
     */
    id?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTypeFields
     */
    name?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTypeFields
     */
    displayName?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTypeFields
     */
    sendIndividualUpdates?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTypeFields
     */
    sendBatchUpdates?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTypeFields
     */
    properties?: boolean;
}
/**
 * 
 * @export
 * @interface DeviceTypeFilter
 */
export interface DeviceTypeFilter {
    /**
     * 
     * @type {number}
     * @memberof DeviceTypeFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceTypeFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceTypeFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof DeviceTypeFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof DeviceTypeFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {DeviceTypeFields}
     * @memberof DeviceTypeFilter
     */
    fields?: DeviceTypeFields;
    /**
     * 
     * @type {Array<DeviceTypeIncludeFilterItems>}
     * @memberof DeviceTypeFilter
     */
    include?: Array<DeviceTypeIncludeFilterItems>;
}
/**
 * 
 * @export
 * @interface DeviceTypeIncludeFilterItems
 */
export interface DeviceTypeIncludeFilterItems {
    /**
     * 
     * @type {string}
     * @memberof DeviceTypeIncludeFilterItems
     */
    relation?: string;
    /**
     * 
     * @type {DeviceTypeScopeFilter}
     * @memberof DeviceTypeIncludeFilterItems
     */
    scope?: DeviceTypeScopeFilter;
}
/**
 * (tsType: Partial<DeviceType>, schemaOptions: { partial: true })
 * @export
 * @interface DeviceTypePartial
 */
export interface DeviceTypePartial {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof DeviceTypePartial
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTypePartial
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTypePartial
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTypePartial
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTypePartial
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTypePartial
     */
    displayName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTypePartial
     */
    sendIndividualUpdates?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTypePartial
     */
    sendBatchUpdates?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof DeviceTypePartial
     */
    properties?: Array<object>;
}
/**
 * 
 * @export
 * @interface DeviceTypeScopeFilter
 */
export interface DeviceTypeScopeFilter {
    /**
     * 
     * @type {number}
     * @memberof DeviceTypeScopeFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceTypeScopeFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceTypeScopeFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof DeviceTypeScopeFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof DeviceTypeScopeFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof DeviceTypeScopeFilter
     */
    fields?: { [key: string]: object; };
    /**
     * 
     * @type {Array<{ [key: string]: object; }>}
     * @memberof DeviceTypeScopeFilter
     */
    include?: Array<{ [key: string]: object; }>;
}
/**
 * (tsType: DeviceTypeWithRelations, schemaOptions: { includeRelations: true })
 * @export
 * @interface DeviceTypeWithRelations
 */
export interface DeviceTypeWithRelations {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof DeviceTypeWithRelations
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTypeWithRelations
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTypeWithRelations
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTypeWithRelations
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTypeWithRelations
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTypeWithRelations
     */
    displayName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTypeWithRelations
     */
    sendIndividualUpdates?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTypeWithRelations
     */
    sendBatchUpdates?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof DeviceTypeWithRelations
     */
    properties?: Array<object>;
    /**
     * 
     * @type {Array<TagTypeWithRelations>}
     * @memberof DeviceTypeWithRelations
     */
    tagTypes?: Array<TagTypeWithRelations>;
    /**
     * 
     * @type {Array<DeviceWithRelations>}
     * @memberof DeviceTypeWithRelations
     */
    devices?: Array<DeviceWithRelations>;
}
/**
 * (tsType: DeviceWithRelations, schemaOptions: { includeRelations: true })
 * @export
 * @interface DeviceWithRelations
 */
export interface DeviceWithRelations {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof DeviceWithRelations
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithRelations
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithRelations
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithRelations
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithRelations
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithRelations
     */
    type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceWithRelations
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithRelations
     */
    deviceTypeId?: string;
    /**
     * 
     * @type {Array<TagWithRelations>}
     * @memberof DeviceWithRelations
     */
    tags?: Array<TagWithRelations>;
    /**
     * 
     * @type {Array<SettingWithRelations>}
     * @memberof DeviceWithRelations
     */
    settings?: Array<SettingWithRelations>;
    /**
     * 
     * @type {DeviceTypeWithRelations}
     * @memberof DeviceWithRelations
     */
    deviceType?: DeviceTypeWithRelations;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    token?: string;
}
/**
 * (tsType: Omit<User, \'id\'>, schemaOptions: { title: \'LoginUser\', exclude: [ \'id\' ] })
 * @export
 * @interface LoginUser
 */
export interface LoginUser {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof LoginUser
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginUser
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginUser
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginUser
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginUser
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof LoginUser
     */
    password: string;
}
/**
 * 
 * @export
 * @interface LoopbackCount
 */
export interface LoopbackCount {
    /**
     * 
     * @type {number}
     * @memberof LoopbackCount
     */
    count?: number;
}
/**
 * (tsType: Alert, schemaOptions: { title: \'NewAlert\' })
 * @export
 * @interface NewAlert
 */
export interface NewAlert {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewAlert
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    period?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    _function?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    context?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    deadbandvalue?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    activationDelay?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    unit?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    FQTagName?: string;
    /**
     * 
     * @type {object}
     * @memberof NewAlert
     */
    metadata?: object;
    /**
     * 
     * @type {object}
     * @memberof NewAlert
     */
    alertinfo?: object;
    /**
     * 
     * @type {string}
     * @memberof NewAlert
     */
    tagId?: string;
}
/**
 * (tsType: @loopback/repository-json-schema#Optional<Omit<Alert, \'id\'>, \'tagId\'>, schemaOptions: { title: \'NewAlertInTag\', exclude: [ \'id\' ], optional: [ \'tagId\' ] })
 * @export
 * @interface NewAlertInTag
 */
export interface NewAlertInTag {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewAlertInTag
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlertInTag
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlertInTag
     */
    updatedOn?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewAlertInTag
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof NewAlertInTag
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlertInTag
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlertInTag
     */
    period?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlertInTag
     */
    _function?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlertInTag
     */
    context?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlertInTag
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlertInTag
     */
    deadbandvalue?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlertInTag
     */
    activationDelay?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlertInTag
     */
    unit?: string;
    /**
     * 
     * @type {string}
     * @memberof NewAlertInTag
     */
    FQTagName?: string;
    /**
     * 
     * @type {object}
     * @memberof NewAlertInTag
     */
    metadata?: object;
    /**
     * 
     * @type {object}
     * @memberof NewAlertInTag
     */
    alertinfo?: object;
    /**
     * 
     * @type {string}
     * @memberof NewAlertInTag
     */
    tagId?: string;
}
/**
 * (tsType: Config, schemaOptions: { title: \'NewConfig\' })
 * @export
 * @interface NewConfig
 */
export interface NewConfig {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewConfig
     */
    id: string;
}
/**
 * (tsType: Omit<Device, \'id\'>, schemaOptions: { title: \'NewDevice\', exclude: [ \'id\' ] })
 * @export
 * @interface NewDevice
 */
export interface NewDevice {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewDevice
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewDevice
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewDevice
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewDevice
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NewDevice
     */
    type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewDevice
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof NewDevice
     */
    deviceTypeId?: string;
}
/**
 * (tsType: @loopback/repository-json-schema#Optional<Omit<Device, \'id\'>, \'deviceTypeId\'>, schemaOptions: { title: \'NewDeviceInDeviceType\', exclude: [ \'id\' ], optional: [ \'deviceTypeId\' ] })
 * @export
 * @interface NewDeviceInDeviceType
 */
export interface NewDeviceInDeviceType {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewDeviceInDeviceType
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeviceInDeviceType
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeviceInDeviceType
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeviceInDeviceType
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeviceInDeviceType
     */
    type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewDeviceInDeviceType
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof NewDeviceInDeviceType
     */
    deviceTypeId?: string;
}
/**
 * (tsType: DeviceType, schemaOptions: { title: \'NewDeviceType\' })
 * @export
 * @interface NewDeviceType
 */
export interface NewDeviceType {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewDeviceType
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeviceType
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeviceType
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeviceType
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeviceType
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeviceType
     */
    displayName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewDeviceType
     */
    sendIndividualUpdates?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewDeviceType
     */
    sendBatchUpdates?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof NewDeviceType
     */
    properties?: Array<object>;
}
/**
 * (tsType: Omit<Notification, \'id\'>, schemaOptions: { title: \'NewNotification\', exclude: [ \'id\' ] })
 * @export
 * @interface NewNotification
 */
export interface NewNotification {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewNotification
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNotification
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNotification
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNotification
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewNotification
     */
    enabled: boolean;
    /**
     * 
     * @type {object}
     * @memberof NewNotification
     */
    email?: object;
    /**
     * 
     * @type {object}
     * @memberof NewNotification
     */
    sms?: object;
    /**
     * 
     * @type {string}
     * @memberof NewNotification
     */
    alertId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewNotification
     */
    recoveryalert?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NewNotification
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNotification
     */
    updationTimeStamp?: string;
}
/**
 * (tsType: @loopback/repository-json-schema#Optional<Omit<Notification, \'id\'>, \'alertId\'>, schemaOptions: { title: \'NewNotificationInAlert\', exclude: [ \'id\' ], optional: [ \'alertId\' ] })
 * @export
 * @interface NewNotificationInAlert
 */
export interface NewNotificationInAlert {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewNotificationInAlert
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNotificationInAlert
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNotificationInAlert
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNotificationInAlert
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewNotificationInAlert
     */
    enabled: boolean;
    /**
     * 
     * @type {object}
     * @memberof NewNotificationInAlert
     */
    email?: object;
    /**
     * 
     * @type {object}
     * @memberof NewNotificationInAlert
     */
    sms?: object;
    /**
     * 
     * @type {string}
     * @memberof NewNotificationInAlert
     */
    alertId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewNotificationInAlert
     */
    recoveryalert?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NewNotificationInAlert
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNotificationInAlert
     */
    updationTimeStamp?: string;
}
/**
 * (tsType: Setting, schemaOptions: { title: \'NewSetting\' })
 * @export
 * @interface NewSetting
 */
export interface NewSetting {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewSetting
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSetting
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSetting
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSetting
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSetting
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof NewSetting
     */
    value?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewSetting
     */
    serialized?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NewSetting
     */
    sertype?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSetting
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSetting
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSetting
     */
    tagId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSetting
     */
    tagGroupId?: string;
}
/**
 * (tsType: Tag, schemaOptions: { title: \'NewTag\' })
 * @export
 * @interface NewTag
 */
export interface NewTag {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewTag
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTag
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTag
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTag
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTag
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewTag
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTag
     */
    tagGroupId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTag
     */
    tagTypeId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTag
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTag
     */
    parentFullName?: string;
}
/**
 * (tsType: TagGroup, schemaOptions: { title: \'NewTagGroup\' })
 * @export
 * @interface NewTagGroup
 */
export interface NewTagGroup {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewTagGroup
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagGroup
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagGroup
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagGroup
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagGroup
     */
    parentId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagGroup
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagGroup
     */
    parentFullName?: string;
}
/**
 * (tsType: @loopback/repository-json-schema#Optional<Omit<TagGroup, \'id\'>, \'parentId\'>, schemaOptions: { title: \'NewTagGroupInTagGroup\', exclude: [ \'id\' ], optional: [ \'parentId\' ] })
 * @export
 * @interface NewTagGroupInTagGroup
 */
export interface NewTagGroupInTagGroup {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewTagGroupInTagGroup
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagGroupInTagGroup
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagGroupInTagGroup
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagGroupInTagGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagGroupInTagGroup
     */
    parentId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagGroupInTagGroup
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagGroupInTagGroup
     */
    parentFullName?: string;
}
/**
 * (tsType: @loopback/repository-json-schema#Optional<Omit<Tag, \'id\'>, \'deviceId\'>, schemaOptions: { title: \'NewTagInDevice\', exclude: [ \'id\' ], optional: [ \'deviceId\' ] })
 * @export
 * @interface NewTagInDevice
 */
export interface NewTagInDevice {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewTagInDevice
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInDevice
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInDevice
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInDevice
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInDevice
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInDevice
     */
    tagGroupId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInDevice
     */
    tagTypeId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInDevice
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInDevice
     */
    parentFullName?: string;
}
/**
 * (tsType: @loopback/repository-json-schema#Optional<Omit<Tag, \'id\'>, \'tagGroupId\'>, schemaOptions: { title: \'NewTagInTagGroup\', exclude: [ \'id\' ], optional: [ \'tagGroupId\' ] })
 * @export
 * @interface NewTagInTagGroup
 */
export interface NewTagInTagGroup {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewTagInTagGroup
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInTagGroup
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInTagGroup
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInTagGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInTagGroup
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInTagGroup
     */
    tagGroupId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInTagGroup
     */
    tagTypeId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInTagGroup
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagInTagGroup
     */
    parentFullName?: string;
}
/**
 * (tsType: TagType, schemaOptions: { title: \'NewTagType\' })
 * @export
 * @interface NewTagType
 */
export interface NewTagType {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewTagType
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagType
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagType
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagType
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagType
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagType
     */
    deviceTypeId?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof NewTagType
     */
    properties?: Array<object>;
}
/**
 * (tsType: @loopback/repository-json-schema#Optional<Omit<TagType, \'name\'>, \'deviceTypeId\'>, schemaOptions: { title: \'NewTagTypeInDeviceType\', exclude: [ \'name\' ], optional: [ \'deviceTypeId\' ] })
 * @export
 * @interface NewTagTypeInDeviceType
 */
export interface NewTagTypeInDeviceType {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewTagTypeInDeviceType
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagTypeInDeviceType
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagTypeInDeviceType
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagTypeInDeviceType
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NewTagTypeInDeviceType
     */
    deviceTypeId?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof NewTagTypeInDeviceType
     */
    properties?: Array<object>;
}
/**
 * (tsType: Omit<User, \'id\'>, schemaOptions: { title: \'NewUser\', exclude: [ \'id\' ] })
 * @export
 * @interface NewUser
 */
export interface NewUser {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NewUser
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NewUser
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewUser
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NewUser
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NewUser
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof NewUser
     */
    password: string;
}
/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    enabled: boolean;
    /**
     * 
     * @type {object}
     * @memberof Notification
     */
    email?: object;
    /**
     * 
     * @type {object}
     * @memberof Notification
     */
    sms?: object;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    alertId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    recoveryalert?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    updationTimeStamp?: string;
}
/**
 * 
 * @export
 * @interface NotificationFields
 */
export interface NotificationFields {
    [key: string]: object | any;

    /**
     * 
     * @type {boolean}
     * @memberof NotificationFields
     */
    version?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationFields
     */
    createdOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationFields
     */
    updatedOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationFields
     */
    id?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationFields
     */
    name?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationFields
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationFields
     */
    email?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationFields
     */
    sms?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationFields
     */
    alertId?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationFields
     */
    recoveryalert?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationFields
     */
    creationTimeStamp?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationFields
     */
    updationTimeStamp?: boolean;
}
/**
 * 
 * @export
 * @interface NotificationFilter
 */
export interface NotificationFilter {
    /**
     * 
     * @type {number}
     * @memberof NotificationFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof NotificationFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof NotificationFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof NotificationFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof NotificationFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {NotificationFields}
     * @memberof NotificationFilter
     */
    fields?: NotificationFields;
    /**
     * 
     * @type {Array<NotificationIncludeFilterItems>}
     * @memberof NotificationFilter
     */
    include?: Array<NotificationIncludeFilterItems>;
}
/**
 * 
 * @export
 * @interface NotificationIncludeFilterItems
 */
export interface NotificationIncludeFilterItems {
    /**
     * 
     * @type {string}
     * @memberof NotificationIncludeFilterItems
     */
    relation?: string;
    /**
     * 
     * @type {NotificationScopeFilter}
     * @memberof NotificationIncludeFilterItems
     */
    scope?: NotificationScopeFilter;
}
/**
 * (tsType: Partial<Notification>, schemaOptions: { partial: true })
 * @export
 * @interface NotificationPartial
 */
export interface NotificationPartial {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NotificationPartial
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationPartial
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationPartial
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationPartial
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationPartial
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationPartial
     */
    enabled?: boolean;
    /**
     * 
     * @type {object}
     * @memberof NotificationPartial
     */
    email?: object;
    /**
     * 
     * @type {object}
     * @memberof NotificationPartial
     */
    sms?: object;
    /**
     * 
     * @type {string}
     * @memberof NotificationPartial
     */
    alertId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationPartial
     */
    recoveryalert?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationPartial
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationPartial
     */
    updationTimeStamp?: string;
}
/**
 * 
 * @export
 * @interface NotificationScopeFilter
 */
export interface NotificationScopeFilter {
    /**
     * 
     * @type {number}
     * @memberof NotificationScopeFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof NotificationScopeFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof NotificationScopeFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof NotificationScopeFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof NotificationScopeFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof NotificationScopeFilter
     */
    fields?: { [key: string]: object; };
    /**
     * 
     * @type {Array<{ [key: string]: object; }>}
     * @memberof NotificationScopeFilter
     */
    include?: Array<{ [key: string]: object; }>;
}
/**
 * (tsType: NotificationWithRelations, schemaOptions: { includeRelations: true })
 * @export
 * @interface NotificationWithRelations
 */
export interface NotificationWithRelations {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof NotificationWithRelations
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationWithRelations
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationWithRelations
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationWithRelations
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationWithRelations
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationWithRelations
     */
    enabled: boolean;
    /**
     * 
     * @type {object}
     * @memberof NotificationWithRelations
     */
    email?: object;
    /**
     * 
     * @type {object}
     * @memberof NotificationWithRelations
     */
    sms?: object;
    /**
     * 
     * @type {string}
     * @memberof NotificationWithRelations
     */
    alertId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationWithRelations
     */
    recoveryalert?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationWithRelations
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationWithRelations
     */
    updationTimeStamp?: string;
    /**
     * 
     * @type {AlertWithRelations}
     * @memberof NotificationWithRelations
     */
    alert?: AlertWithRelations;
}
/**
 * 
 * @export
 * @interface Setting
 */
export interface Setting {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    value?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Setting
     */
    serialized?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    sertype?: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    tagId?: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    tagGroupId?: string;
}
/**
 * 
 * @export
 * @interface SettingFields
 */
export interface SettingFields {
    /**
     * 
     * @type {boolean}
     * @memberof SettingFields
     */
    version?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SettingFields
     */
    createdOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SettingFields
     */
    updatedOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SettingFields
     */
    id?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SettingFields
     */
    key?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SettingFields
     */
    value?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SettingFields
     */
    serialized?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SettingFields
     */
    sertype?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SettingFields
     */
    type?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SettingFields
     */
    deviceId?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SettingFields
     */
    tagId?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SettingFields
     */
    tagGroupId?: boolean;
}
/**
 * 
 * @export
 * @interface SettingFilter
 */
export interface SettingFilter {
    /**
     * 
     * @type {number}
     * @memberof SettingFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof SettingFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof SettingFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof SettingFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SettingFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {SettingFields}
     * @memberof SettingFilter
     */
    fields?: SettingFields;
}
/**
 * (tsType: Partial<Setting>, schemaOptions: { partial: true })
 * @export
 * @interface SettingPartial
 */
export interface SettingPartial {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof SettingPartial
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingPartial
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingPartial
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingPartial
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingPartial
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingPartial
     */
    value?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SettingPartial
     */
    serialized?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SettingPartial
     */
    sertype?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingPartial
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingPartial
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingPartial
     */
    tagId?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingPartial
     */
    tagGroupId?: string;
}
/**
 * (tsType: SettingWithRelations, schemaOptions: { includeRelations: true })
 * @export
 * @interface SettingWithRelations
 */
export interface SettingWithRelations {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof SettingWithRelations
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingWithRelations
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingWithRelations
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingWithRelations
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingWithRelations
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof SettingWithRelations
     */
    value?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SettingWithRelations
     */
    serialized?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SettingWithRelations
     */
    sertype?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingWithRelations
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingWithRelations
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingWithRelations
     */
    tagId?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingWithRelations
     */
    tagGroupId?: string;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    tagGroupId?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    tagTypeId?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    parentFullName?: string;
}
/**
 * 
 * @export
 * @interface TagFields
 */
export interface TagFields {
    [key: string]: object | any;

    /**
     * 
     * @type {boolean}
     * @memberof TagFields
     */
    version?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagFields
     */
    createdOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagFields
     */
    updatedOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagFields
     */
    id?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagFields
     */
    name?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagFields
     */
    creationTimeStamp?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagFields
     */
    tagGroupId?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagFields
     */
    tagTypeId?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagFields
     */
    deviceId?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagFields
     */
    parentFullName?: boolean;
}
/**
 * 
 * @export
 * @interface TagFilter
 */
export interface TagFilter {
    /**
     * 
     * @type {number}
     * @memberof TagFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof TagFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof TagFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof TagFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof TagFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {TagFields}
     * @memberof TagFilter
     */
    fields?: TagFields;
    /**
     * 
     * @type {Array<TagIncludeFilterItems>}
     * @memberof TagFilter
     */
    include?: Array<TagIncludeFilterItems>;
}
/**
 * 
 * @export
 * @interface TagGroup
 */
export interface TagGroup {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof TagGroup
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroup
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroup
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroup
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroup
     */
    parentId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroup
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroup
     */
    parentFullName?: string;
}
/**
 * 
 * @export
 * @interface TagGroupFields
 */
export interface TagGroupFields {
    [key: string]: object | any;

    /**
     * 
     * @type {boolean}
     * @memberof TagGroupFields
     */
    version?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagGroupFields
     */
    createdOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagGroupFields
     */
    updatedOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagGroupFields
     */
    id?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagGroupFields
     */
    name?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagGroupFields
     */
    parentId?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagGroupFields
     */
    creationTimeStamp?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagGroupFields
     */
    parentFullName?: boolean;
}
/**
 * 
 * @export
 * @interface TagGroupFilter
 */
export interface TagGroupFilter {
    /**
     * 
     * @type {number}
     * @memberof TagGroupFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof TagGroupFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof TagGroupFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof TagGroupFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof TagGroupFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {TagGroupFields}
     * @memberof TagGroupFilter
     */
    fields?: TagGroupFields;
    /**
     * 
     * @type {Array<TagGroupIncludeFilterItems>}
     * @memberof TagGroupFilter
     */
    include?: Array<TagGroupIncludeFilterItems>;
}
/**
 * 
 * @export
 * @interface TagGroupIncludeFilterItems
 */
export interface TagGroupIncludeFilterItems {
    /**
     * 
     * @type {string}
     * @memberof TagGroupIncludeFilterItems
     */
    relation?: string;
    /**
     * 
     * @type {TagGroupScopeFilter}
     * @memberof TagGroupIncludeFilterItems
     */
    scope?: TagGroupScopeFilter;
}
/**
 * (tsType: Partial<TagGroup>, schemaOptions: { partial: true })
 * @export
 * @interface TagGroupPartial
 */
export interface TagGroupPartial {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof TagGroupPartial
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroupPartial
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroupPartial
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroupPartial
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroupPartial
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroupPartial
     */
    parentId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroupPartial
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroupPartial
     */
    parentFullName?: string;
}
/**
 * 
 * @export
 * @interface TagGroupScopeFilter
 */
export interface TagGroupScopeFilter {
    /**
     * 
     * @type {number}
     * @memberof TagGroupScopeFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof TagGroupScopeFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof TagGroupScopeFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof TagGroupScopeFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof TagGroupScopeFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof TagGroupScopeFilter
     */
    fields?: { [key: string]: object; };
    /**
     * 
     * @type {Array<{ [key: string]: object; }>}
     * @memberof TagGroupScopeFilter
     */
    include?: Array<{ [key: string]: object; }>;
}
/**
 * (tsType: TagGroupWithRelations, schemaOptions: { includeRelations: true })
 * @export
 * @interface TagGroupWithRelations
 */
export interface TagGroupWithRelations {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof TagGroupWithRelations
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroupWithRelations
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroupWithRelations
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroupWithRelations
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroupWithRelations
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroupWithRelations
     */
    parentId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroupWithRelations
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof TagGroupWithRelations
     */
    parentFullName?: string;
    /**
     * 
     * @type {Array<TagWithRelations>}
     * @memberof TagGroupWithRelations
     */
    tags?: Array<TagWithRelations>;
    /**
     * 
     * @type {Array<TagGroupWithRelations>}
     * @memberof TagGroupWithRelations
     */
    subgroups?: Array<TagGroupWithRelations>;
}
/**
 * 
 * @export
 * @interface TagIncludeFilterItems
 */
export interface TagIncludeFilterItems {
    /**
     * 
     * @type {string}
     * @memberof TagIncludeFilterItems
     */
    relation?: string;
    /**
     * 
     * @type {TagScopeFilter}
     * @memberof TagIncludeFilterItems
     */
    scope?: TagScopeFilter;
}
/**
 * (tsType: Partial<Tag>, schemaOptions: { partial: true })
 * @export
 * @interface TagPartial
 */
export interface TagPartial {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof TagPartial
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof TagPartial
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagPartial
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagPartial
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TagPartial
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TagPartial
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof TagPartial
     */
    tagGroupId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagPartial
     */
    tagTypeId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagPartial
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagPartial
     */
    parentFullName?: string;
}
/**
 * 
 * @export
 * @interface TagScopeFilter
 */
export interface TagScopeFilter {
    /**
     * 
     * @type {number}
     * @memberof TagScopeFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof TagScopeFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof TagScopeFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof TagScopeFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof TagScopeFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof TagScopeFilter
     */
    fields?: { [key: string]: object; };
    /**
     * 
     * @type {Array<{ [key: string]: object; }>}
     * @memberof TagScopeFilter
     */
    include?: Array<{ [key: string]: object; }>;
}
/**
 * 
 * @export
 * @interface TagType
 */
export interface TagType {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof TagType
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof TagType
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagType
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagType
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TagType
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TagType
     */
    deviceTypeId?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof TagType
     */
    properties?: Array<object>;
}
/**
 * 
 * @export
 * @interface TagTypeFields
 */
export interface TagTypeFields {
    [key: string]: object | any;

    /**
     * 
     * @type {boolean}
     * @memberof TagTypeFields
     */
    version?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagTypeFields
     */
    createdOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagTypeFields
     */
    updatedOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagTypeFields
     */
    id?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagTypeFields
     */
    name?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagTypeFields
     */
    deviceTypeId?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TagTypeFields
     */
    properties?: boolean;
}
/**
 * 
 * @export
 * @interface TagTypeFilter
 */
export interface TagTypeFilter {
    /**
     * 
     * @type {number}
     * @memberof TagTypeFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof TagTypeFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof TagTypeFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof TagTypeFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof TagTypeFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {TagTypeFields}
     * @memberof TagTypeFilter
     */
    fields?: TagTypeFields;
}
/**
 * (tsType: Partial<TagType>, schemaOptions: { partial: true })
 * @export
 * @interface TagTypePartial
 */
export interface TagTypePartial {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof TagTypePartial
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof TagTypePartial
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagTypePartial
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagTypePartial
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TagTypePartial
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TagTypePartial
     */
    deviceTypeId?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof TagTypePartial
     */
    properties?: Array<object>;
}
/**
 * (tsType: TagTypeWithRelations, schemaOptions: { includeRelations: true })
 * @export
 * @interface TagTypeWithRelations
 */
export interface TagTypeWithRelations {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof TagTypeWithRelations
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof TagTypeWithRelations
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagTypeWithRelations
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagTypeWithRelations
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TagTypeWithRelations
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TagTypeWithRelations
     */
    deviceTypeId?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof TagTypeWithRelations
     */
    properties?: Array<object>;
}
/**
 * (tsType: TagWithRelations, schemaOptions: { includeRelations: true })
 * @export
 * @interface TagWithRelations
 */
export interface TagWithRelations {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof TagWithRelations
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof TagWithRelations
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagWithRelations
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof TagWithRelations
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TagWithRelations
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TagWithRelations
     */
    creationTimeStamp?: string;
    /**
     * 
     * @type {string}
     * @memberof TagWithRelations
     */
    tagGroupId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagWithRelations
     */
    tagTypeId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagWithRelations
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagWithRelations
     */
    parentFullName?: string;
    /**
     * 
     * @type {TagGroupWithRelations}
     * @memberof TagWithRelations
     */
    tagGroup?: TagGroupWithRelations;
    /**
     * 
     * @type {Array<AlertWithRelations>}
     * @memberof TagWithRelations
     */
    alerts?: Array<AlertWithRelations>;
    /**
     * 
     * @type {TagTypeWithRelations}
     * @memberof TagWithRelations
     */
    tagType?: TagTypeWithRelations;
    /**
     * 
     * @type {DeviceWithRelations}
     * @memberof TagWithRelations
     */
    device?: DeviceWithRelations;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof User
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password: string;
}
/**
 * 
 * @export
 * @interface UserFields
 */
export interface UserFields {
    /**
     * 
     * @type {boolean}
     * @memberof UserFields
     */
    version?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFields
     */
    createdOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFields
     */
    updatedOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFields
     */
    id?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFields
     */
    name?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFields
     */
    email?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFields
     */
    password?: boolean;
}
/**
 * 
 * @export
 * @interface UserFilter
 */
export interface UserFilter {
    /**
     * 
     * @type {number}
     * @memberof UserFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof UserFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof UserFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof UserFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof UserFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {UserFields}
     * @memberof UserFilter
     */
    fields?: UserFields;
}
/**
 * (tsType: Partial<User>, schemaOptions: { partial: true })
 * @export
 * @interface UserPartial
 */
export interface UserPartial {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof UserPartial
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPartial
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPartial
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPartial
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPartial
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPartial
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPartial
     */
    password?: string;
}
/**
 * (tsType: UserWithRelations, schemaOptions: { includeRelations: true })
 * @export
 * @interface UserWithRelations
 */
export interface UserWithRelations {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof UserWithRelations
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWithRelations
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWithRelations
     */
    updatedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWithRelations
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWithRelations
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWithRelations
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof UserWithRelations
     */
    password: string;
}
/**
 * 
 * @export
 * @interface VersionedEntityFields
 */
export interface VersionedEntityFields {
    [key: string]: object | any;

    /**
     * 
     * @type {boolean}
     * @memberof VersionedEntityFields
     */
    version?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VersionedEntityFields
     */
    createdOn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VersionedEntityFields
     */
    updatedOn?: boolean;
}
/**
 * 
 * @export
 * @interface VersionedEntityFilter
 */
export interface VersionedEntityFilter {
    /**
     * 
     * @type {number}
     * @memberof VersionedEntityFilter
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof VersionedEntityFilter
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof VersionedEntityFilter
     */
    skip?: number;
    /**
     * 
     * @type {string | Array<string>}
     * @memberof VersionedEntityFilter
     */
    order?: string | Array<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof VersionedEntityFilter
     */
    where?: { [key: string]: object; };
    /**
     * 
     * @type {VersionedEntityFields}
     * @memberof VersionedEntityFilter
     */
    fields?: VersionedEntityFields;
    /**
     * 
     * @type {Array<DeviceTypeIncludeFilterItems>}
     * @memberof VersionedEntityFilter
     */
    include?: Array<DeviceTypeIncludeFilterItems>;
}

/**
 * AlertControllerApi - axios parameter creator
 * @export
 */
export const AlertControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerCommit(options: any = {}): RequestArgs {
            const localVarPath = `/alerts/commit`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerCount(where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/alerts/count`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerCreate(requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/alerts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerDeleteAll(options: any = {}): RequestArgs {
            const localVarPath = `/alerts/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerDeleteById(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertControllerDeleteById.');
            }
            const localVarPath = `/alerts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AlertFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerFind(filter?: AlertFilter, options: any = {}): RequestArgs {
            const localVarPath = `/alerts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {AlertFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerFindById(id: string, filter?: AlertFilter, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertControllerFindById.');
            }
            const localVarPath = `/alerts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertControllerReplaceById.');
            }
            const localVarPath = `/alerts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/alerts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertControllerUpdateById.');
            }
            const localVarPath = `/alerts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertControllerApi - functional programming interface
 * @export
 */
export const AlertControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerCommit(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = AlertControllerApiAxiosParamCreator(configuration).alertControllerCommit(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerCount(where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = AlertControllerApiAxiosParamCreator(configuration).alertControllerCount(where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerCreate(requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alert> {
            const localVarAxiosArgs = AlertControllerApiAxiosParamCreator(configuration).alertControllerCreate(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerDeleteAll(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = AlertControllerApiAxiosParamCreator(configuration).alertControllerDeleteAll(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerDeleteById(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = AlertControllerApiAxiosParamCreator(configuration).alertControllerDeleteById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {AlertFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerFind(filter?: AlertFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlertWithRelations>> {
            const localVarAxiosArgs = AlertControllerApiAxiosParamCreator(configuration).alertControllerFind(filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {AlertFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerFindById(id: string, filter?: AlertFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertWithRelations> {
            const localVarAxiosArgs = AlertControllerApiAxiosParamCreator(configuration).alertControllerFindById(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = AlertControllerApiAxiosParamCreator(configuration).alertControllerReplaceById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = AlertControllerApiAxiosParamCreator(configuration).alertControllerUpdateAll(where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = AlertControllerApiAxiosParamCreator(configuration).alertControllerUpdateById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AlertControllerApi - factory interface
 * @export
 */
export const AlertControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerCommit(options?: any): AxiosPromise<void> {
            return AlertControllerApiFp(configuration).alertControllerCommit(options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerCount(where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return AlertControllerApiFp(configuration).alertControllerCount(where, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerCreate(requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<Alert> {
            return AlertControllerApiFp(configuration).alertControllerCreate(requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerDeleteAll(options?: any): AxiosPromise<void> {
            return AlertControllerApiFp(configuration).alertControllerDeleteAll(options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerDeleteById(id: string, options?: any): AxiosPromise<void> {
            return AlertControllerApiFp(configuration).alertControllerDeleteById(id, options)(axios, basePath);
        },
        /**
         * 
         * @param {AlertFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerFind(filter?: AlertFilter, options?: any): AxiosPromise<Array<AlertWithRelations>> {
            return AlertControllerApiFp(configuration).alertControllerFind(filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {AlertFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerFindById(id: string, filter?: AlertFilter, options?: any): AxiosPromise<AlertWithRelations> {
            return AlertControllerApiFp(configuration).alertControllerFindById(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return AlertControllerApiFp(configuration).alertControllerReplaceById(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return AlertControllerApiFp(configuration).alertControllerUpdateAll(where, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return AlertControllerApiFp(configuration).alertControllerUpdateById(id, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * AlertControllerApi - object-oriented interface
 * @export
 * @class AlertControllerApi
 * @extends {BaseAPI}
 */
export class AlertControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertControllerApi
     */
    public alertControllerCommit(options?: any) {
        return AlertControllerApiFp(this.configuration).alertControllerCommit(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertControllerApi
     */
    public alertControllerCount(where?: { [key: string]: object; }, options?: any) {
        return AlertControllerApiFp(this.configuration).alertControllerCount(where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertControllerApi
     */
    public alertControllerCreate(requestBody?: { [key: string]: object; }, options?: any) {
        return AlertControllerApiFp(this.configuration).alertControllerCreate(requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertControllerApi
     */
    public alertControllerDeleteAll(options?: any) {
        return AlertControllerApiFp(this.configuration).alertControllerDeleteAll(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertControllerApi
     */
    public alertControllerDeleteById(id: string, options?: any) {
        return AlertControllerApiFp(this.configuration).alertControllerDeleteById(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {AlertFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertControllerApi
     */
    public alertControllerFind(filter?: AlertFilter, options?: any) {
        return AlertControllerApiFp(this.configuration).alertControllerFind(filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {AlertFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertControllerApi
     */
    public alertControllerFindById(id: string, filter?: AlertFilter, options?: any) {
        return AlertControllerApiFp(this.configuration).alertControllerFindById(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertControllerApi
     */
    public alertControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return AlertControllerApiFp(this.configuration).alertControllerReplaceById(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertControllerApi
     */
    public alertControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return AlertControllerApiFp(this.configuration).alertControllerUpdateAll(where, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertControllerApi
     */
    public alertControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return AlertControllerApiFp(this.configuration).alertControllerUpdateById(id, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * AlertNotificationControllerApi - axios parameter creator
 * @export
 */
export const AlertNotificationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertNotificationControllerCreate(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertNotificationControllerCreate.');
            }
            const localVarPath = `/alerts/{id}/notifications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertNotificationControllerDelete(id: string, where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertNotificationControllerDelete.');
            }
            const localVarPath = `/alerts/{id}/notifications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertNotificationControllerFind(id: string, filter?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertNotificationControllerFind.');
            }
            const localVarPath = `/alerts/{id}/notifications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertNotificationControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertNotificationControllerPatch.');
            }
            const localVarPath = `/alerts/{id}/notifications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertNotificationControllerApi - functional programming interface
 * @export
 */
export const AlertNotificationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertNotificationControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification> {
            const localVarAxiosArgs = AlertNotificationControllerApiAxiosParamCreator(configuration).alertNotificationControllerCreate(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertNotificationControllerDelete(id: string, where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = AlertNotificationControllerApiAxiosParamCreator(configuration).alertNotificationControllerDelete(id, where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertNotificationControllerFind(id: string, filter?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notification>> {
            const localVarAxiosArgs = AlertNotificationControllerApiAxiosParamCreator(configuration).alertNotificationControllerFind(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertNotificationControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = AlertNotificationControllerApiAxiosParamCreator(configuration).alertNotificationControllerPatch(id, where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AlertNotificationControllerApi - factory interface
 * @export
 */
export const AlertNotificationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertNotificationControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<Notification> {
            return AlertNotificationControllerApiFp(configuration).alertNotificationControllerCreate(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertNotificationControllerDelete(id: string, where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return AlertNotificationControllerApiFp(configuration).alertNotificationControllerDelete(id, where, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertNotificationControllerFind(id: string, filter?: { [key: string]: object; }, options?: any): AxiosPromise<Array<Notification>> {
            return AlertNotificationControllerApiFp(configuration).alertNotificationControllerFind(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertNotificationControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return AlertNotificationControllerApiFp(configuration).alertNotificationControllerPatch(id, where, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * AlertNotificationControllerApi - object-oriented interface
 * @export
 * @class AlertNotificationControllerApi
 * @extends {BaseAPI}
 */
export class AlertNotificationControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertNotificationControllerApi
     */
    public alertNotificationControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return AlertNotificationControllerApiFp(this.configuration).alertNotificationControllerCreate(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertNotificationControllerApi
     */
    public alertNotificationControllerDelete(id: string, where?: { [key: string]: object; }, options?: any) {
        return AlertNotificationControllerApiFp(this.configuration).alertNotificationControllerDelete(id, where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertNotificationControllerApi
     */
    public alertNotificationControllerFind(id: string, filter?: { [key: string]: object; }, options?: any) {
        return AlertNotificationControllerApiFp(this.configuration).alertNotificationControllerFind(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertNotificationControllerApi
     */
    public alertNotificationControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return AlertNotificationControllerApiFp(this.configuration).alertNotificationControllerPatch(id, where, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * AlertTagControllerApi - axios parameter creator
 * @export
 */
export const AlertTagControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertTagControllerGetTag(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertTagControllerGetTag.');
            }
            const localVarPath = `/alerts/{id}/tag`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertTagControllerApi - functional programming interface
 * @export
 */
export const AlertTagControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertTagControllerGetTag(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>> {
            const localVarAxiosArgs = AlertTagControllerApiAxiosParamCreator(configuration).alertTagControllerGetTag(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AlertTagControllerApi - factory interface
 * @export
 */
export const AlertTagControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertTagControllerGetTag(id: string, options?: any): AxiosPromise<Array<Tag>> {
            return AlertTagControllerApiFp(configuration).alertTagControllerGetTag(id, options)(axios, basePath);
        },
    };
};

/**
 * AlertTagControllerApi - object-oriented interface
 * @export
 * @class AlertTagControllerApi
 * @extends {BaseAPI}
 */
export class AlertTagControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTagControllerApi
     */
    public alertTagControllerGetTag(id: string, options?: any) {
        return AlertTagControllerApiFp(this.configuration).alertTagControllerGetTag(id, options)(this.axios, this.basePath);
    }

}


/**
 * CommitControllerApi - axios parameter creator
 * @export
 */
export const CommitControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitControllerCommit(options: any = {}): RequestArgs {
            const localVarPath = `/commit`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommitControllerApi - functional programming interface
 * @export
 */
export const CommitControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitControllerCommit(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = CommitControllerApiAxiosParamCreator(configuration).commitControllerCommit(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CommitControllerApi - factory interface
 * @export
 */
export const CommitControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitControllerCommit(options?: any): AxiosPromise<void> {
            return CommitControllerApiFp(configuration).commitControllerCommit(options)(axios, basePath);
        },
    };
};

/**
 * CommitControllerApi - object-oriented interface
 * @export
 * @class CommitControllerApi
 * @extends {BaseAPI}
 */
export class CommitControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommitControllerApi
     */
    public commitControllerCommit(options?: any) {
        return CommitControllerApiFp(this.configuration).commitControllerCommit(options)(this.axios, this.basePath);
    }

}


/**
 * ConfigControllerApi - axios parameter creator
 * @export
 */
export const ConfigControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerCount(where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/configs/count`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerCreate(requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/configs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerDeleteById(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling configControllerDeleteById.');
            }
            const localVarPath = `/configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConfigFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerFind(filter?: ConfigFilter, options: any = {}): RequestArgs {
            const localVarPath = `/configs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ConfigFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerFindById(id: string, filter?: ConfigFilter, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling configControllerFindById.');
            }
            const localVarPath = `/configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling configControllerReplaceById.');
            }
            const localVarPath = `/configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/configs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling configControllerUpdateById.');
            }
            const localVarPath = `/configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigControllerApi - functional programming interface
 * @export
 */
export const ConfigControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerCount(where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = ConfigControllerApiAxiosParamCreator(configuration).configControllerCount(where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerCreate(requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config> {
            const localVarAxiosArgs = ConfigControllerApiAxiosParamCreator(configuration).configControllerCreate(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerDeleteById(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = ConfigControllerApiAxiosParamCreator(configuration).configControllerDeleteById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ConfigFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerFind(filter?: ConfigFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConfigWithRelations>> {
            const localVarAxiosArgs = ConfigControllerApiAxiosParamCreator(configuration).configControllerFind(filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ConfigFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerFindById(id: string, filter?: ConfigFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigWithRelations> {
            const localVarAxiosArgs = ConfigControllerApiAxiosParamCreator(configuration).configControllerFindById(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = ConfigControllerApiAxiosParamCreator(configuration).configControllerReplaceById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = ConfigControllerApiAxiosParamCreator(configuration).configControllerUpdateAll(where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = ConfigControllerApiAxiosParamCreator(configuration).configControllerUpdateById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConfigControllerApi - factory interface
 * @export
 */
export const ConfigControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerCount(where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return ConfigControllerApiFp(configuration).configControllerCount(where, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerCreate(requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<Config> {
            return ConfigControllerApiFp(configuration).configControllerCreate(requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerDeleteById(id: string, options?: any): AxiosPromise<void> {
            return ConfigControllerApiFp(configuration).configControllerDeleteById(id, options)(axios, basePath);
        },
        /**
         * 
         * @param {ConfigFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerFind(filter?: ConfigFilter, options?: any): AxiosPromise<Array<ConfigWithRelations>> {
            return ConfigControllerApiFp(configuration).configControllerFind(filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ConfigFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerFindById(id: string, filter?: ConfigFilter, options?: any): AxiosPromise<ConfigWithRelations> {
            return ConfigControllerApiFp(configuration).configControllerFindById(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return ConfigControllerApiFp(configuration).configControllerReplaceById(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return ConfigControllerApiFp(configuration).configControllerUpdateAll(where, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return ConfigControllerApiFp(configuration).configControllerUpdateById(id, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * ConfigControllerApi - object-oriented interface
 * @export
 * @class ConfigControllerApi
 * @extends {BaseAPI}
 */
export class ConfigControllerApi extends BaseAPI {
    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public configControllerCount(where?: { [key: string]: object; }, options?: any) {
        return ConfigControllerApiFp(this.configuration).configControllerCount(where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public configControllerCreate(requestBody?: { [key: string]: object; }, options?: any) {
        return ConfigControllerApiFp(this.configuration).configControllerCreate(requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public configControllerDeleteById(id: string, options?: any) {
        return ConfigControllerApiFp(this.configuration).configControllerDeleteById(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {ConfigFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public configControllerFind(filter?: ConfigFilter, options?: any) {
        return ConfigControllerApiFp(this.configuration).configControllerFind(filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {ConfigFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public configControllerFindById(id: string, filter?: ConfigFilter, options?: any) {
        return ConfigControllerApiFp(this.configuration).configControllerFindById(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public configControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return ConfigControllerApiFp(this.configuration).configControllerReplaceById(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public configControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return ConfigControllerApiFp(this.configuration).configControllerUpdateAll(where, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigControllerApi
     */
    public configControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return ConfigControllerApiFp(this.configuration).configControllerUpdateById(id, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * DeviceControllerApi - axios parameter creator
 * @export
 */
export const DeviceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerCommit(options: any = {}): RequestArgs {
            const localVarPath = `/devices/commit`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerCount(where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/devices/count`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerCreate(requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/devices`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerDeleteAll(where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/devices/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerDeleteById(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceControllerDeleteById.');
            }
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeviceFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerFind(filter?: DeviceFilter, options: any = {}): RequestArgs {
            const localVarPath = `/devices`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DeviceFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerFindById(id: string, filter?: DeviceFilter, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceControllerFindById.');
            }
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceControllerReplaceById.');
            }
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/devices`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceControllerUpdateById.');
            }
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceControllerApi - functional programming interface
 * @export
 */
export const DeviceControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerCommit(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DeviceControllerApiAxiosParamCreator(configuration).deviceControllerCommit(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerCount(where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = DeviceControllerApiAxiosParamCreator(configuration).deviceControllerCount(where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerCreate(requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device> {
            const localVarAxiosArgs = DeviceControllerApiAxiosParamCreator(configuration).deviceControllerCreate(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerDeleteAll(where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DeviceControllerApiAxiosParamCreator(configuration).deviceControllerDeleteAll(where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerDeleteById(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DeviceControllerApiAxiosParamCreator(configuration).deviceControllerDeleteById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {DeviceFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerFind(filter?: DeviceFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceWithRelations>> {
            const localVarAxiosArgs = DeviceControllerApiAxiosParamCreator(configuration).deviceControllerFind(filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DeviceFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerFindById(id: string, filter?: DeviceFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceWithRelations> {
            const localVarAxiosArgs = DeviceControllerApiAxiosParamCreator(configuration).deviceControllerFindById(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DeviceControllerApiAxiosParamCreator(configuration).deviceControllerReplaceById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = DeviceControllerApiAxiosParamCreator(configuration).deviceControllerUpdateAll(where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DeviceControllerApiAxiosParamCreator(configuration).deviceControllerUpdateById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DeviceControllerApi - factory interface
 * @export
 */
export const DeviceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerCommit(options?: any): AxiosPromise<void> {
            return DeviceControllerApiFp(configuration).deviceControllerCommit(options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerCount(where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return DeviceControllerApiFp(configuration).deviceControllerCount(where, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerCreate(requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<Device> {
            return DeviceControllerApiFp(configuration).deviceControllerCreate(requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerDeleteAll(where?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return DeviceControllerApiFp(configuration).deviceControllerDeleteAll(where, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerDeleteById(id: string, options?: any): AxiosPromise<void> {
            return DeviceControllerApiFp(configuration).deviceControllerDeleteById(id, options)(axios, basePath);
        },
        /**
         * 
         * @param {DeviceFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerFind(filter?: DeviceFilter, options?: any): AxiosPromise<Array<DeviceWithRelations>> {
            return DeviceControllerApiFp(configuration).deviceControllerFind(filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {DeviceFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerFindById(id: string, filter?: DeviceFilter, options?: any): AxiosPromise<DeviceWithRelations> {
            return DeviceControllerApiFp(configuration).deviceControllerFindById(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return DeviceControllerApiFp(configuration).deviceControllerReplaceById(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return DeviceControllerApiFp(configuration).deviceControllerUpdateAll(where, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return DeviceControllerApiFp(configuration).deviceControllerUpdateById(id, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * DeviceControllerApi - object-oriented interface
 * @export
 * @class DeviceControllerApi
 * @extends {BaseAPI}
 */
export class DeviceControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public deviceControllerCommit(options?: any) {
        return DeviceControllerApiFp(this.configuration).deviceControllerCommit(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public deviceControllerCount(where?: { [key: string]: object; }, options?: any) {
        return DeviceControllerApiFp(this.configuration).deviceControllerCount(where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public deviceControllerCreate(requestBody?: { [key: string]: object; }, options?: any) {
        return DeviceControllerApiFp(this.configuration).deviceControllerCreate(requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public deviceControllerDeleteAll(where?: { [key: string]: object; }, options?: any) {
        return DeviceControllerApiFp(this.configuration).deviceControllerDeleteAll(where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public deviceControllerDeleteById(id: string, options?: any) {
        return DeviceControllerApiFp(this.configuration).deviceControllerDeleteById(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {DeviceFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public deviceControllerFind(filter?: DeviceFilter, options?: any) {
        return DeviceControllerApiFp(this.configuration).deviceControllerFind(filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {DeviceFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public deviceControllerFindById(id: string, filter?: DeviceFilter, options?: any) {
        return DeviceControllerApiFp(this.configuration).deviceControllerFindById(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public deviceControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return DeviceControllerApiFp(this.configuration).deviceControllerReplaceById(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public deviceControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return DeviceControllerApiFp(this.configuration).deviceControllerUpdateAll(where, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceControllerApi
     */
    public deviceControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return DeviceControllerApiFp(this.configuration).deviceControllerUpdateById(id, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * DeviceDeviceTypeControllerApi - axios parameter creator
 * @export
 */
export const DeviceDeviceTypeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceDeviceTypeControllerGetDeviceType(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceDeviceTypeControllerGetDeviceType.');
            }
            const localVarPath = `/devices/{id}/device-type`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceDeviceTypeControllerApi - functional programming interface
 * @export
 */
export const DeviceDeviceTypeControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceDeviceTypeControllerGetDeviceType(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceType>> {
            const localVarAxiosArgs = DeviceDeviceTypeControllerApiAxiosParamCreator(configuration).deviceDeviceTypeControllerGetDeviceType(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DeviceDeviceTypeControllerApi - factory interface
 * @export
 */
export const DeviceDeviceTypeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceDeviceTypeControllerGetDeviceType(id: string, options?: any): AxiosPromise<Array<DeviceType>> {
            return DeviceDeviceTypeControllerApiFp(configuration).deviceDeviceTypeControllerGetDeviceType(id, options)(axios, basePath);
        },
    };
};

/**
 * DeviceDeviceTypeControllerApi - object-oriented interface
 * @export
 * @class DeviceDeviceTypeControllerApi
 * @extends {BaseAPI}
 */
export class DeviceDeviceTypeControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceDeviceTypeControllerApi
     */
    public deviceDeviceTypeControllerGetDeviceType(id: string, options?: any) {
        return DeviceDeviceTypeControllerApiFp(this.configuration).deviceDeviceTypeControllerGetDeviceType(id, options)(this.axios, this.basePath);
    }

}


/**
 * DeviceTagControllerApi - axios parameter creator
 * @export
 */
export const DeviceTagControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTagControllerCreate(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTagControllerCreate.');
            }
            const localVarPath = `/devices/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTagControllerDelete(id: string, where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTagControllerDelete.');
            }
            const localVarPath = `/devices/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTagControllerFind(id: string, filter?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTagControllerFind.');
            }
            const localVarPath = `/devices/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTagControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTagControllerPatch.');
            }
            const localVarPath = `/devices/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceTagControllerApi - functional programming interface
 * @export
 */
export const DeviceTagControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTagControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag> {
            const localVarAxiosArgs = DeviceTagControllerApiAxiosParamCreator(configuration).deviceTagControllerCreate(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTagControllerDelete(id: string, where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = DeviceTagControllerApiAxiosParamCreator(configuration).deviceTagControllerDelete(id, where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTagControllerFind(id: string, filter?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>> {
            const localVarAxiosArgs = DeviceTagControllerApiAxiosParamCreator(configuration).deviceTagControllerFind(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTagControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = DeviceTagControllerApiAxiosParamCreator(configuration).deviceTagControllerPatch(id, where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DeviceTagControllerApi - factory interface
 * @export
 */
export const DeviceTagControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTagControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<Tag> {
            return DeviceTagControllerApiFp(configuration).deviceTagControllerCreate(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTagControllerDelete(id: string, where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return DeviceTagControllerApiFp(configuration).deviceTagControllerDelete(id, where, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTagControllerFind(id: string, filter?: { [key: string]: object; }, options?: any): AxiosPromise<Array<Tag>> {
            return DeviceTagControllerApiFp(configuration).deviceTagControllerFind(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTagControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return DeviceTagControllerApiFp(configuration).deviceTagControllerPatch(id, where, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * DeviceTagControllerApi - object-oriented interface
 * @export
 * @class DeviceTagControllerApi
 * @extends {BaseAPI}
 */
export class DeviceTagControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTagControllerApi
     */
    public deviceTagControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return DeviceTagControllerApiFp(this.configuration).deviceTagControllerCreate(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTagControllerApi
     */
    public deviceTagControllerDelete(id: string, where?: { [key: string]: object; }, options?: any) {
        return DeviceTagControllerApiFp(this.configuration).deviceTagControllerDelete(id, where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTagControllerApi
     */
    public deviceTagControllerFind(id: string, filter?: { [key: string]: object; }, options?: any) {
        return DeviceTagControllerApiFp(this.configuration).deviceTagControllerFind(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTagControllerApi
     */
    public deviceTagControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return DeviceTagControllerApiFp(this.configuration).deviceTagControllerPatch(id, where, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * DeviceTypeControllerApi - axios parameter creator
 * @export
 */
export const DeviceTypeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerCount(where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/device-types/count`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerCreate(requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/device-types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerDeleteAll(options: any = {}): RequestArgs {
            const localVarPath = `/device-type/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerDeleteById(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTypeControllerDeleteById.');
            }
            const localVarPath = `/device-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VersionedEntityFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerFind(filter?: VersionedEntityFilter, options: any = {}): RequestArgs {
            const localVarPath = `/device-types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DeviceTypeFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerFindById(id: string, filter?: DeviceTypeFilter, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTypeControllerFindById.');
            }
            const localVarPath = `/device-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTypeControllerReplaceById.');
            }
            const localVarPath = `/device-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/device-types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTypeControllerUpdateById.');
            }
            const localVarPath = `/device-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceTypeControllerApi - functional programming interface
 * @export
 */
export const DeviceTypeControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerCount(where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = DeviceTypeControllerApiAxiosParamCreator(configuration).deviceTypeControllerCount(where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerCreate(requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceType> {
            const localVarAxiosArgs = DeviceTypeControllerApiAxiosParamCreator(configuration).deviceTypeControllerCreate(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerDeleteAll(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DeviceTypeControllerApiAxiosParamCreator(configuration).deviceTypeControllerDeleteAll(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerDeleteById(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DeviceTypeControllerApiAxiosParamCreator(configuration).deviceTypeControllerDeleteById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {VersionedEntityFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerFind(filter?: VersionedEntityFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceTypeWithRelations>> {
            const localVarAxiosArgs = DeviceTypeControllerApiAxiosParamCreator(configuration).deviceTypeControllerFind(filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DeviceTypeFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerFindById(id: string, filter?: DeviceTypeFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceTypeWithRelations> {
            const localVarAxiosArgs = DeviceTypeControllerApiAxiosParamCreator(configuration).deviceTypeControllerFindById(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DeviceTypeControllerApiAxiosParamCreator(configuration).deviceTypeControllerReplaceById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = DeviceTypeControllerApiAxiosParamCreator(configuration).deviceTypeControllerUpdateAll(where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DeviceTypeControllerApiAxiosParamCreator(configuration).deviceTypeControllerUpdateById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DeviceTypeControllerApi - factory interface
 * @export
 */
export const DeviceTypeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerCount(where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return DeviceTypeControllerApiFp(configuration).deviceTypeControllerCount(where, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerCreate(requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<DeviceType> {
            return DeviceTypeControllerApiFp(configuration).deviceTypeControllerCreate(requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerDeleteAll(options?: any): AxiosPromise<void> {
            return DeviceTypeControllerApiFp(configuration).deviceTypeControllerDeleteAll(options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerDeleteById(id: string, options?: any): AxiosPromise<void> {
            return DeviceTypeControllerApiFp(configuration).deviceTypeControllerDeleteById(id, options)(axios, basePath);
        },
        /**
         * 
         * @param {VersionedEntityFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerFind(filter?: VersionedEntityFilter, options?: any): AxiosPromise<Array<DeviceTypeWithRelations>> {
            return DeviceTypeControllerApiFp(configuration).deviceTypeControllerFind(filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {DeviceTypeFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerFindById(id: string, filter?: DeviceTypeFilter, options?: any): AxiosPromise<DeviceTypeWithRelations> {
            return DeviceTypeControllerApiFp(configuration).deviceTypeControllerFindById(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return DeviceTypeControllerApiFp(configuration).deviceTypeControllerReplaceById(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return DeviceTypeControllerApiFp(configuration).deviceTypeControllerUpdateAll(where, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return DeviceTypeControllerApiFp(configuration).deviceTypeControllerUpdateById(id, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * DeviceTypeControllerApi - object-oriented interface
 * @export
 * @class DeviceTypeControllerApi
 * @extends {BaseAPI}
 */
export class DeviceTypeControllerApi extends BaseAPI {
    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeControllerApi
     */
    public deviceTypeControllerCount(where?: { [key: string]: object; }, options?: any) {
        return DeviceTypeControllerApiFp(this.configuration).deviceTypeControllerCount(where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeControllerApi
     */
    public deviceTypeControllerCreate(requestBody?: { [key: string]: object; }, options?: any) {
        return DeviceTypeControllerApiFp(this.configuration).deviceTypeControllerCreate(requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeControllerApi
     */
    public deviceTypeControllerDeleteAll(options?: any) {
        return DeviceTypeControllerApiFp(this.configuration).deviceTypeControllerDeleteAll(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeControllerApi
     */
    public deviceTypeControllerDeleteById(id: string, options?: any) {
        return DeviceTypeControllerApiFp(this.configuration).deviceTypeControllerDeleteById(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {VersionedEntityFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeControllerApi
     */
    public deviceTypeControllerFind(filter?: VersionedEntityFilter, options?: any) {
        return DeviceTypeControllerApiFp(this.configuration).deviceTypeControllerFind(filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {DeviceTypeFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeControllerApi
     */
    public deviceTypeControllerFindById(id: string, filter?: DeviceTypeFilter, options?: any) {
        return DeviceTypeControllerApiFp(this.configuration).deviceTypeControllerFindById(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeControllerApi
     */
    public deviceTypeControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return DeviceTypeControllerApiFp(this.configuration).deviceTypeControllerReplaceById(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeControllerApi
     */
    public deviceTypeControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return DeviceTypeControllerApiFp(this.configuration).deviceTypeControllerUpdateAll(where, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeControllerApi
     */
    public deviceTypeControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return DeviceTypeControllerApiFp(this.configuration).deviceTypeControllerUpdateById(id, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * DeviceTypeDeviceControllerApi - axios parameter creator
 * @export
 */
export const DeviceTypeDeviceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeDeviceControllerCreate(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTypeDeviceControllerCreate.');
            }
            const localVarPath = `/device-types/{id}/devices`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeDeviceControllerDelete(id: string, where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTypeDeviceControllerDelete.');
            }
            const localVarPath = `/device-types/{id}/devices`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeDeviceControllerFind(id: string, filter?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTypeDeviceControllerFind.');
            }
            const localVarPath = `/device-types/{id}/devices`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeDeviceControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTypeDeviceControllerPatch.');
            }
            const localVarPath = `/device-types/{id}/devices`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceTypeDeviceControllerApi - functional programming interface
 * @export
 */
export const DeviceTypeDeviceControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeDeviceControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device> {
            const localVarAxiosArgs = DeviceTypeDeviceControllerApiAxiosParamCreator(configuration).deviceTypeDeviceControllerCreate(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeDeviceControllerDelete(id: string, where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = DeviceTypeDeviceControllerApiAxiosParamCreator(configuration).deviceTypeDeviceControllerDelete(id, where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeDeviceControllerFind(id: string, filter?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>> {
            const localVarAxiosArgs = DeviceTypeDeviceControllerApiAxiosParamCreator(configuration).deviceTypeDeviceControllerFind(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeDeviceControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = DeviceTypeDeviceControllerApiAxiosParamCreator(configuration).deviceTypeDeviceControllerPatch(id, where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DeviceTypeDeviceControllerApi - factory interface
 * @export
 */
export const DeviceTypeDeviceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeDeviceControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<Device> {
            return DeviceTypeDeviceControllerApiFp(configuration).deviceTypeDeviceControllerCreate(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeDeviceControllerDelete(id: string, where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return DeviceTypeDeviceControllerApiFp(configuration).deviceTypeDeviceControllerDelete(id, where, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeDeviceControllerFind(id: string, filter?: { [key: string]: object; }, options?: any): AxiosPromise<Array<Device>> {
            return DeviceTypeDeviceControllerApiFp(configuration).deviceTypeDeviceControllerFind(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeDeviceControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return DeviceTypeDeviceControllerApiFp(configuration).deviceTypeDeviceControllerPatch(id, where, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * DeviceTypeDeviceControllerApi - object-oriented interface
 * @export
 * @class DeviceTypeDeviceControllerApi
 * @extends {BaseAPI}
 */
export class DeviceTypeDeviceControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeDeviceControllerApi
     */
    public deviceTypeDeviceControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return DeviceTypeDeviceControllerApiFp(this.configuration).deviceTypeDeviceControllerCreate(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeDeviceControllerApi
     */
    public deviceTypeDeviceControllerDelete(id: string, where?: { [key: string]: object; }, options?: any) {
        return DeviceTypeDeviceControllerApiFp(this.configuration).deviceTypeDeviceControllerDelete(id, where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeDeviceControllerApi
     */
    public deviceTypeDeviceControllerFind(id: string, filter?: { [key: string]: object; }, options?: any) {
        return DeviceTypeDeviceControllerApiFp(this.configuration).deviceTypeDeviceControllerFind(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeDeviceControllerApi
     */
    public deviceTypeDeviceControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return DeviceTypeDeviceControllerApiFp(this.configuration).deviceTypeDeviceControllerPatch(id, where, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * DeviceTypeTagTypeControllerApi - axios parameter creator
 * @export
 */
export const DeviceTypeTagTypeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeTagTypeControllerCreate(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTypeTagTypeControllerCreate.');
            }
            const localVarPath = `/device-types/{id}/tag-types`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeTagTypeControllerDelete(id: string, where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTypeTagTypeControllerDelete.');
            }
            const localVarPath = `/device-types/{id}/tag-types`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeTagTypeControllerFind(id: string, filter?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTypeTagTypeControllerFind.');
            }
            const localVarPath = `/device-types/{id}/tag-types`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeTagTypeControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceTypeTagTypeControllerPatch.');
            }
            const localVarPath = `/device-types/{id}/tag-types`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceTypeTagTypeControllerApi - functional programming interface
 * @export
 */
export const DeviceTypeTagTypeControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeTagTypeControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagType> {
            const localVarAxiosArgs = DeviceTypeTagTypeControllerApiAxiosParamCreator(configuration).deviceTypeTagTypeControllerCreate(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeTagTypeControllerDelete(id: string, where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = DeviceTypeTagTypeControllerApiAxiosParamCreator(configuration).deviceTypeTagTypeControllerDelete(id, where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeTagTypeControllerFind(id: string, filter?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagType>> {
            const localVarAxiosArgs = DeviceTypeTagTypeControllerApiAxiosParamCreator(configuration).deviceTypeTagTypeControllerFind(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeTagTypeControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = DeviceTypeTagTypeControllerApiAxiosParamCreator(configuration).deviceTypeTagTypeControllerPatch(id, where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DeviceTypeTagTypeControllerApi - factory interface
 * @export
 */
export const DeviceTypeTagTypeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeTagTypeControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<TagType> {
            return DeviceTypeTagTypeControllerApiFp(configuration).deviceTypeTagTypeControllerCreate(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeTagTypeControllerDelete(id: string, where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return DeviceTypeTagTypeControllerApiFp(configuration).deviceTypeTagTypeControllerDelete(id, where, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeTagTypeControllerFind(id: string, filter?: { [key: string]: object; }, options?: any): AxiosPromise<Array<TagType>> {
            return DeviceTypeTagTypeControllerApiFp(configuration).deviceTypeTagTypeControllerFind(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceTypeTagTypeControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return DeviceTypeTagTypeControllerApiFp(configuration).deviceTypeTagTypeControllerPatch(id, where, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * DeviceTypeTagTypeControllerApi - object-oriented interface
 * @export
 * @class DeviceTypeTagTypeControllerApi
 * @extends {BaseAPI}
 */
export class DeviceTypeTagTypeControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeTagTypeControllerApi
     */
    public deviceTypeTagTypeControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return DeviceTypeTagTypeControllerApiFp(this.configuration).deviceTypeTagTypeControllerCreate(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeTagTypeControllerApi
     */
    public deviceTypeTagTypeControllerDelete(id: string, where?: { [key: string]: object; }, options?: any) {
        return DeviceTypeTagTypeControllerApiFp(this.configuration).deviceTypeTagTypeControllerDelete(id, where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeTagTypeControllerApi
     */
    public deviceTypeTagTypeControllerFind(id: string, filter?: { [key: string]: object; }, options?: any) {
        return DeviceTypeTagTypeControllerApiFp(this.configuration).deviceTypeTagTypeControllerFind(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTypeTagTypeControllerApi
     */
    public deviceTypeTagTypeControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return DeviceTypeTagTypeControllerApiFp(this.configuration).deviceTypeTagTypeControllerPatch(id, where, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * InfoControllerApi - axios parameter creator
 * @export
 */
export const InfoControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoControllerFind(options: any = {}): RequestArgs {
            const localVarPath = `/info`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoControllerApi - functional programming interface
 * @export
 */
export const InfoControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoControllerFind(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = InfoControllerApiAxiosParamCreator(configuration).infoControllerFind(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InfoControllerApi - factory interface
 * @export
 */
export const InfoControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoControllerFind(options?: any): AxiosPromise<object> {
            return InfoControllerApiFp(configuration).infoControllerFind(options)(axios, basePath);
        },
    };
};

/**
 * InfoControllerApi - object-oriented interface
 * @export
 * @class InfoControllerApi
 * @extends {BaseAPI}
 */
export class InfoControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoControllerApi
     */
    public infoControllerFind(options?: any) {
        return InfoControllerApiFp(this.configuration).infoControllerFind(options)(this.axios, this.basePath);
    }

}


/**
 * NotificationAlertControllerApi - axios parameter creator
 * @export
 */
export const NotificationAlertControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationAlertControllerGetAlert(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling notificationAlertControllerGetAlert.');
            }
            const localVarPath = `/notifications/{id}/alert`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationAlertControllerApi - functional programming interface
 * @export
 */
export const NotificationAlertControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationAlertControllerGetAlert(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Alert>> {
            const localVarAxiosArgs = NotificationAlertControllerApiAxiosParamCreator(configuration).notificationAlertControllerGetAlert(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NotificationAlertControllerApi - factory interface
 * @export
 */
export const NotificationAlertControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationAlertControllerGetAlert(id: string, options?: any): AxiosPromise<Array<Alert>> {
            return NotificationAlertControllerApiFp(configuration).notificationAlertControllerGetAlert(id, options)(axios, basePath);
        },
    };
};

/**
 * NotificationAlertControllerApi - object-oriented interface
 * @export
 * @class NotificationAlertControllerApi
 * @extends {BaseAPI}
 */
export class NotificationAlertControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationAlertControllerApi
     */
    public notificationAlertControllerGetAlert(id: string, options?: any) {
        return NotificationAlertControllerApiFp(this.configuration).notificationAlertControllerGetAlert(id, options)(this.axios, this.basePath);
    }

}


/**
 * NotificationControllerApi - axios parameter creator
 * @export
 */
export const NotificationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerCount(where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/notifications/count`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerCreate(requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/notifications`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerDeleteAll(options: any = {}): RequestArgs {
            const localVarPath = `/notifications/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerDeleteById(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling notificationControllerDeleteById.');
            }
            const localVarPath = `/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NotificationFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerFind(filter?: NotificationFilter, options: any = {}): RequestArgs {
            const localVarPath = `/notifications`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {NotificationFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerFindById(id: string, filter?: NotificationFilter, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling notificationControllerFindById.');
            }
            const localVarPath = `/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling notificationControllerReplaceById.');
            }
            const localVarPath = `/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/notifications`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling notificationControllerUpdateById.');
            }
            const localVarPath = `/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationControllerApi - functional programming interface
 * @export
 */
export const NotificationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerCount(where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = NotificationControllerApiAxiosParamCreator(configuration).notificationControllerCount(where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerCreate(requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification> {
            const localVarAxiosArgs = NotificationControllerApiAxiosParamCreator(configuration).notificationControllerCreate(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerDeleteAll(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = NotificationControllerApiAxiosParamCreator(configuration).notificationControllerDeleteAll(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerDeleteById(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = NotificationControllerApiAxiosParamCreator(configuration).notificationControllerDeleteById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {NotificationFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerFind(filter?: NotificationFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationWithRelations>> {
            const localVarAxiosArgs = NotificationControllerApiAxiosParamCreator(configuration).notificationControllerFind(filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {NotificationFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerFindById(id: string, filter?: NotificationFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationWithRelations> {
            const localVarAxiosArgs = NotificationControllerApiAxiosParamCreator(configuration).notificationControllerFindById(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = NotificationControllerApiAxiosParamCreator(configuration).notificationControllerReplaceById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = NotificationControllerApiAxiosParamCreator(configuration).notificationControllerUpdateAll(where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = NotificationControllerApiAxiosParamCreator(configuration).notificationControllerUpdateById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NotificationControllerApi - factory interface
 * @export
 */
export const NotificationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerCount(where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return NotificationControllerApiFp(configuration).notificationControllerCount(where, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerCreate(requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<Notification> {
            return NotificationControllerApiFp(configuration).notificationControllerCreate(requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerDeleteAll(options?: any): AxiosPromise<void> {
            return NotificationControllerApiFp(configuration).notificationControllerDeleteAll(options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerDeleteById(id: string, options?: any): AxiosPromise<void> {
            return NotificationControllerApiFp(configuration).notificationControllerDeleteById(id, options)(axios, basePath);
        },
        /**
         * 
         * @param {NotificationFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerFind(filter?: NotificationFilter, options?: any): AxiosPromise<Array<NotificationWithRelations>> {
            return NotificationControllerApiFp(configuration).notificationControllerFind(filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {NotificationFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerFindById(id: string, filter?: NotificationFilter, options?: any): AxiosPromise<NotificationWithRelations> {
            return NotificationControllerApiFp(configuration).notificationControllerFindById(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return NotificationControllerApiFp(configuration).notificationControllerReplaceById(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return NotificationControllerApiFp(configuration).notificationControllerUpdateAll(where, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return NotificationControllerApiFp(configuration).notificationControllerUpdateById(id, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * NotificationControllerApi - object-oriented interface
 * @export
 * @class NotificationControllerApi
 * @extends {BaseAPI}
 */
export class NotificationControllerApi extends BaseAPI {
    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationControllerApi
     */
    public notificationControllerCount(where?: { [key: string]: object; }, options?: any) {
        return NotificationControllerApiFp(this.configuration).notificationControllerCount(where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationControllerApi
     */
    public notificationControllerCreate(requestBody?: { [key: string]: object; }, options?: any) {
        return NotificationControllerApiFp(this.configuration).notificationControllerCreate(requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationControllerApi
     */
    public notificationControllerDeleteAll(options?: any) {
        return NotificationControllerApiFp(this.configuration).notificationControllerDeleteAll(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationControllerApi
     */
    public notificationControllerDeleteById(id: string, options?: any) {
        return NotificationControllerApiFp(this.configuration).notificationControllerDeleteById(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {NotificationFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationControllerApi
     */
    public notificationControllerFind(filter?: NotificationFilter, options?: any) {
        return NotificationControllerApiFp(this.configuration).notificationControllerFind(filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {NotificationFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationControllerApi
     */
    public notificationControllerFindById(id: string, filter?: NotificationFilter, options?: any) {
        return NotificationControllerApiFp(this.configuration).notificationControllerFindById(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationControllerApi
     */
    public notificationControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return NotificationControllerApiFp(this.configuration).notificationControllerReplaceById(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationControllerApi
     */
    public notificationControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return NotificationControllerApiFp(this.configuration).notificationControllerUpdateAll(where, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationControllerApi
     */
    public notificationControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return NotificationControllerApiFp(this.configuration).notificationControllerUpdateById(id, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * SettingControllerApi - axios parameter creator
 * @export
 */
export const SettingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerCount(where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/settings/count`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerCreate(requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerDeleteById(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling settingControllerDeleteById.');
            }
            const localVarPath = `/settings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SettingFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerFind(filter?: SettingFilter, options: any = {}): RequestArgs {
            const localVarPath = `/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SettingFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerFindById(id: string, filter?: SettingFilter, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling settingControllerFindById.');
            }
            const localVarPath = `/settings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling settingControllerReplaceById.');
            }
            const localVarPath = `/settings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling settingControllerUpdateById.');
            }
            const localVarPath = `/settings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingControllerApi - functional programming interface
 * @export
 */
export const SettingControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerCount(where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = SettingControllerApiAxiosParamCreator(configuration).settingControllerCount(where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerCreate(requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting> {
            const localVarAxiosArgs = SettingControllerApiAxiosParamCreator(configuration).settingControllerCreate(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerDeleteById(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = SettingControllerApiAxiosParamCreator(configuration).settingControllerDeleteById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SettingFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerFind(filter?: SettingFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SettingWithRelations>> {
            const localVarAxiosArgs = SettingControllerApiAxiosParamCreator(configuration).settingControllerFind(filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SettingFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerFindById(id: string, filter?: SettingFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingWithRelations> {
            const localVarAxiosArgs = SettingControllerApiAxiosParamCreator(configuration).settingControllerFindById(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = SettingControllerApiAxiosParamCreator(configuration).settingControllerReplaceById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = SettingControllerApiAxiosParamCreator(configuration).settingControllerUpdateAll(where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = SettingControllerApiAxiosParamCreator(configuration).settingControllerUpdateById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SettingControllerApi - factory interface
 * @export
 */
export const SettingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerCount(where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return SettingControllerApiFp(configuration).settingControllerCount(where, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerCreate(requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<Setting> {
            return SettingControllerApiFp(configuration).settingControllerCreate(requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerDeleteById(id: string, options?: any): AxiosPromise<void> {
            return SettingControllerApiFp(configuration).settingControllerDeleteById(id, options)(axios, basePath);
        },
        /**
         * 
         * @param {SettingFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerFind(filter?: SettingFilter, options?: any): AxiosPromise<Array<SettingWithRelations>> {
            return SettingControllerApiFp(configuration).settingControllerFind(filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {SettingFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerFindById(id: string, filter?: SettingFilter, options?: any): AxiosPromise<SettingWithRelations> {
            return SettingControllerApiFp(configuration).settingControllerFindById(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return SettingControllerApiFp(configuration).settingControllerReplaceById(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return SettingControllerApiFp(configuration).settingControllerUpdateAll(where, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return SettingControllerApiFp(configuration).settingControllerUpdateById(id, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * SettingControllerApi - object-oriented interface
 * @export
 * @class SettingControllerApi
 * @extends {BaseAPI}
 */
export class SettingControllerApi extends BaseAPI {
    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public settingControllerCount(where?: { [key: string]: object; }, options?: any) {
        return SettingControllerApiFp(this.configuration).settingControllerCount(where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public settingControllerCreate(requestBody?: { [key: string]: object; }, options?: any) {
        return SettingControllerApiFp(this.configuration).settingControllerCreate(requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public settingControllerDeleteById(id: string, options?: any) {
        return SettingControllerApiFp(this.configuration).settingControllerDeleteById(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {SettingFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public settingControllerFind(filter?: SettingFilter, options?: any) {
        return SettingControllerApiFp(this.configuration).settingControllerFind(filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {SettingFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public settingControllerFindById(id: string, filter?: SettingFilter, options?: any) {
        return SettingControllerApiFp(this.configuration).settingControllerFindById(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public settingControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return SettingControllerApiFp(this.configuration).settingControllerReplaceById(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public settingControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return SettingControllerApiFp(this.configuration).settingControllerUpdateAll(where, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingControllerApi
     */
    public settingControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return SettingControllerApiFp(this.configuration).settingControllerUpdateById(id, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * TagAlertControllerApi - axios parameter creator
 * @export
 */
export const TagAlertControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAlertControllerCreate(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagAlertControllerCreate.');
            }
            const localVarPath = `/tags/{id}/alerts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAlertControllerDelete(id: string, where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagAlertControllerDelete.');
            }
            const localVarPath = `/tags/{id}/alerts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAlertControllerFind(id: string, filter?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagAlertControllerFind.');
            }
            const localVarPath = `/tags/{id}/alerts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAlertControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagAlertControllerPatch.');
            }
            const localVarPath = `/tags/{id}/alerts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagAlertControllerApi - functional programming interface
 * @export
 */
export const TagAlertControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAlertControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alert> {
            const localVarAxiosArgs = TagAlertControllerApiAxiosParamCreator(configuration).tagAlertControllerCreate(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAlertControllerDelete(id: string, where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = TagAlertControllerApiAxiosParamCreator(configuration).tagAlertControllerDelete(id, where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAlertControllerFind(id: string, filter?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Alert>> {
            const localVarAxiosArgs = TagAlertControllerApiAxiosParamCreator(configuration).tagAlertControllerFind(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAlertControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = TagAlertControllerApiAxiosParamCreator(configuration).tagAlertControllerPatch(id, where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagAlertControllerApi - factory interface
 * @export
 */
export const TagAlertControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAlertControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<Alert> {
            return TagAlertControllerApiFp(configuration).tagAlertControllerCreate(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAlertControllerDelete(id: string, where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return TagAlertControllerApiFp(configuration).tagAlertControllerDelete(id, where, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAlertControllerFind(id: string, filter?: { [key: string]: object; }, options?: any): AxiosPromise<Array<Alert>> {
            return TagAlertControllerApiFp(configuration).tagAlertControllerFind(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagAlertControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return TagAlertControllerApiFp(configuration).tagAlertControllerPatch(id, where, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * TagAlertControllerApi - object-oriented interface
 * @export
 * @class TagAlertControllerApi
 * @extends {BaseAPI}
 */
export class TagAlertControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagAlertControllerApi
     */
    public tagAlertControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return TagAlertControllerApiFp(this.configuration).tagAlertControllerCreate(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagAlertControllerApi
     */
    public tagAlertControllerDelete(id: string, where?: { [key: string]: object; }, options?: any) {
        return TagAlertControllerApiFp(this.configuration).tagAlertControllerDelete(id, where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagAlertControllerApi
     */
    public tagAlertControllerFind(id: string, filter?: { [key: string]: object; }, options?: any) {
        return TagAlertControllerApiFp(this.configuration).tagAlertControllerFind(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagAlertControllerApi
     */
    public tagAlertControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return TagAlertControllerApiFp(this.configuration).tagAlertControllerPatch(id, where, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * TagControllerApi - axios parameter creator
 * @export
 */
export const TagControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerCount(where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/tags/count`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerCreate(requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerDeleteAll(options: any = {}): RequestArgs {
            const localVarPath = `/tags/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerDeleteById(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagControllerDeleteById.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TagFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFind(filter?: TagFilter, options: any = {}): RequestArgs {
            const localVarPath = `/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {TagFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindById(id: string, filter?: TagFilter, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagControllerFindById.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagControllerReplaceById.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagControllerUpdateById.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagControllerApi - functional programming interface
 * @export
 */
export const TagControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerCount(where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = TagControllerApiAxiosParamCreator(configuration).tagControllerCount(where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerCreate(requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag> {
            const localVarAxiosArgs = TagControllerApiAxiosParamCreator(configuration).tagControllerCreate(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerDeleteAll(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TagControllerApiAxiosParamCreator(configuration).tagControllerDeleteAll(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerDeleteById(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TagControllerApiAxiosParamCreator(configuration).tagControllerDeleteById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {TagFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFind(filter?: TagFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagWithRelations>> {
            const localVarAxiosArgs = TagControllerApiAxiosParamCreator(configuration).tagControllerFind(filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {TagFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindById(id: string, filter?: TagFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagWithRelations> {
            const localVarAxiosArgs = TagControllerApiAxiosParamCreator(configuration).tagControllerFindById(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TagControllerApiAxiosParamCreator(configuration).tagControllerReplaceById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = TagControllerApiAxiosParamCreator(configuration).tagControllerUpdateAll(where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TagControllerApiAxiosParamCreator(configuration).tagControllerUpdateById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagControllerApi - factory interface
 * @export
 */
export const TagControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerCount(where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return TagControllerApiFp(configuration).tagControllerCount(where, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerCreate(requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<Tag> {
            return TagControllerApiFp(configuration).tagControllerCreate(requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerDeleteAll(options?: any): AxiosPromise<void> {
            return TagControllerApiFp(configuration).tagControllerDeleteAll(options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerDeleteById(id: string, options?: any): AxiosPromise<void> {
            return TagControllerApiFp(configuration).tagControllerDeleteById(id, options)(axios, basePath);
        },
        /**
         * 
         * @param {TagFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFind(filter?: TagFilter, options?: any): AxiosPromise<Array<TagWithRelations>> {
            return TagControllerApiFp(configuration).tagControllerFind(filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {TagFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerFindById(id: string, filter?: TagFilter, options?: any): AxiosPromise<TagWithRelations> {
            return TagControllerApiFp(configuration).tagControllerFindById(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return TagControllerApiFp(configuration).tagControllerReplaceById(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return TagControllerApiFp(configuration).tagControllerUpdateAll(where, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return TagControllerApiFp(configuration).tagControllerUpdateById(id, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * TagControllerApi - object-oriented interface
 * @export
 * @class TagControllerApi
 * @extends {BaseAPI}
 */
export class TagControllerApi extends BaseAPI {
    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public tagControllerCount(where?: { [key: string]: object; }, options?: any) {
        return TagControllerApiFp(this.configuration).tagControllerCount(where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public tagControllerCreate(requestBody?: { [key: string]: object; }, options?: any) {
        return TagControllerApiFp(this.configuration).tagControllerCreate(requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public tagControllerDeleteAll(options?: any) {
        return TagControllerApiFp(this.configuration).tagControllerDeleteAll(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public tagControllerDeleteById(id: string, options?: any) {
        return TagControllerApiFp(this.configuration).tagControllerDeleteById(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {TagFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public tagControllerFind(filter?: TagFilter, options?: any) {
        return TagControllerApiFp(this.configuration).tagControllerFind(filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {TagFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public tagControllerFindById(id: string, filter?: TagFilter, options?: any) {
        return TagControllerApiFp(this.configuration).tagControllerFindById(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public tagControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return TagControllerApiFp(this.configuration).tagControllerReplaceById(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public tagControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return TagControllerApiFp(this.configuration).tagControllerUpdateAll(where, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public tagControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return TagControllerApiFp(this.configuration).tagControllerUpdateById(id, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * TagDeviceControllerApi - axios parameter creator
 * @export
 */
export const TagDeviceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDeviceControllerGetDevice(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagDeviceControllerGetDevice.');
            }
            const localVarPath = `/tags/{id}/device`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagDeviceControllerApi - functional programming interface
 * @export
 */
export const TagDeviceControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDeviceControllerGetDevice(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>> {
            const localVarAxiosArgs = TagDeviceControllerApiAxiosParamCreator(configuration).tagDeviceControllerGetDevice(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagDeviceControllerApi - factory interface
 * @export
 */
export const TagDeviceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDeviceControllerGetDevice(id: string, options?: any): AxiosPromise<Array<Device>> {
            return TagDeviceControllerApiFp(configuration).tagDeviceControllerGetDevice(id, options)(axios, basePath);
        },
    };
};

/**
 * TagDeviceControllerApi - object-oriented interface
 * @export
 * @class TagDeviceControllerApi
 * @extends {BaseAPI}
 */
export class TagDeviceControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDeviceControllerApi
     */
    public tagDeviceControllerGetDevice(id: string, options?: any) {
        return TagDeviceControllerApiFp(this.configuration).tagDeviceControllerGetDevice(id, options)(this.axios, this.basePath);
    }

}


/**
 * TagGroupControllerApi - axios parameter creator
 * @export
 */
export const TagGroupControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerCommit(options: any = {}): RequestArgs {
            const localVarPath = `/tag-groups/commit`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerCount(where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/tag-groups/count`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerCreate(requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/tag-groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerDeleteAll(options: any = {}): RequestArgs {
            const localVarPath = `/tag-groups/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerDeleteById(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagGroupControllerDeleteById.');
            }
            const localVarPath = `/tag-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TagGroupFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerFind(filter?: TagGroupFilter, options: any = {}): RequestArgs {
            const localVarPath = `/tag-groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerFindAllWithRelation(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagGroupControllerFindAllWithRelation.');
            }
            const localVarPath = `/all-tag-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerFindAllWithRelationTopLevel(options: any = {}): RequestArgs {
            const localVarPath = `/all-tag-groups-top-level`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {TagGroupFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerFindById(id: string, filter?: TagGroupFilter, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagGroupControllerFindById.');
            }
            const localVarPath = `/tag-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagGroupControllerReplaceById.');
            }
            const localVarPath = `/tag-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/tag-groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagGroupControllerUpdateById.');
            }
            const localVarPath = `/tag-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagGroupControllerApi - functional programming interface
 * @export
 */
export const TagGroupControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerCommit(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TagGroupControllerApiAxiosParamCreator(configuration).tagGroupControllerCommit(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerCount(where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = TagGroupControllerApiAxiosParamCreator(configuration).tagGroupControllerCount(where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerCreate(requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagGroup> {
            const localVarAxiosArgs = TagGroupControllerApiAxiosParamCreator(configuration).tagGroupControllerCreate(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerDeleteAll(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TagGroupControllerApiAxiosParamCreator(configuration).tagGroupControllerDeleteAll(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerDeleteById(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TagGroupControllerApiAxiosParamCreator(configuration).tagGroupControllerDeleteById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {TagGroupFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerFind(filter?: TagGroupFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagGroupWithRelations>> {
            const localVarAxiosArgs = TagGroupControllerApiAxiosParamCreator(configuration).tagGroupControllerFind(filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerFindAllWithRelation(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagGroupWithRelations>> {
            const localVarAxiosArgs = TagGroupControllerApiAxiosParamCreator(configuration).tagGroupControllerFindAllWithRelation(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerFindAllWithRelationTopLevel(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagGroupWithRelations>> {
            const localVarAxiosArgs = TagGroupControllerApiAxiosParamCreator(configuration).tagGroupControllerFindAllWithRelationTopLevel(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {TagGroupFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerFindById(id: string, filter?: TagGroupFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagGroupWithRelations> {
            const localVarAxiosArgs = TagGroupControllerApiAxiosParamCreator(configuration).tagGroupControllerFindById(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TagGroupControllerApiAxiosParamCreator(configuration).tagGroupControllerReplaceById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = TagGroupControllerApiAxiosParamCreator(configuration).tagGroupControllerUpdateAll(where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TagGroupControllerApiAxiosParamCreator(configuration).tagGroupControllerUpdateById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagGroupControllerApi - factory interface
 * @export
 */
export const TagGroupControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerCommit(options?: any): AxiosPromise<void> {
            return TagGroupControllerApiFp(configuration).tagGroupControllerCommit(options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerCount(where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return TagGroupControllerApiFp(configuration).tagGroupControllerCount(where, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerCreate(requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<TagGroup> {
            return TagGroupControllerApiFp(configuration).tagGroupControllerCreate(requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerDeleteAll(options?: any): AxiosPromise<void> {
            return TagGroupControllerApiFp(configuration).tagGroupControllerDeleteAll(options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerDeleteById(id: string, options?: any): AxiosPromise<void> {
            return TagGroupControllerApiFp(configuration).tagGroupControllerDeleteById(id, options)(axios, basePath);
        },
        /**
         * 
         * @param {TagGroupFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerFind(filter?: TagGroupFilter, options?: any): AxiosPromise<Array<TagGroupWithRelations>> {
            return TagGroupControllerApiFp(configuration).tagGroupControllerFind(filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerFindAllWithRelation(id: string, options?: any): AxiosPromise<Array<TagGroupWithRelations>> {
            return TagGroupControllerApiFp(configuration).tagGroupControllerFindAllWithRelation(id, options)(axios, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerFindAllWithRelationTopLevel(options?: any): AxiosPromise<Array<TagGroupWithRelations>> {
            return TagGroupControllerApiFp(configuration).tagGroupControllerFindAllWithRelationTopLevel(options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {TagGroupFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerFindById(id: string, filter?: TagGroupFilter, options?: any): AxiosPromise<TagGroupWithRelations> {
            return TagGroupControllerApiFp(configuration).tagGroupControllerFindById(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return TagGroupControllerApiFp(configuration).tagGroupControllerReplaceById(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return TagGroupControllerApiFp(configuration).tagGroupControllerUpdateAll(where, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return TagGroupControllerApiFp(configuration).tagGroupControllerUpdateById(id, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * TagGroupControllerApi - object-oriented interface
 * @export
 * @class TagGroupControllerApi
 * @extends {BaseAPI}
 */
export class TagGroupControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupControllerApi
     */
    public tagGroupControllerCommit(options?: any) {
        return TagGroupControllerApiFp(this.configuration).tagGroupControllerCommit(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupControllerApi
     */
    public tagGroupControllerCount(where?: { [key: string]: object; }, options?: any) {
        return TagGroupControllerApiFp(this.configuration).tagGroupControllerCount(where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupControllerApi
     */
    public tagGroupControllerCreate(requestBody?: { [key: string]: object; }, options?: any) {
        return TagGroupControllerApiFp(this.configuration).tagGroupControllerCreate(requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupControllerApi
     */
    public tagGroupControllerDeleteAll(options?: any) {
        return TagGroupControllerApiFp(this.configuration).tagGroupControllerDeleteAll(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupControllerApi
     */
    public tagGroupControllerDeleteById(id: string, options?: any) {
        return TagGroupControllerApiFp(this.configuration).tagGroupControllerDeleteById(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {TagGroupFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupControllerApi
     */
    public tagGroupControllerFind(filter?: TagGroupFilter, options?: any) {
        return TagGroupControllerApiFp(this.configuration).tagGroupControllerFind(filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupControllerApi
     */
    public tagGroupControllerFindAllWithRelation(id: string, options?: any) {
        return TagGroupControllerApiFp(this.configuration).tagGroupControllerFindAllWithRelation(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupControllerApi
     */
    public tagGroupControllerFindAllWithRelationTopLevel(options?: any) {
        return TagGroupControllerApiFp(this.configuration).tagGroupControllerFindAllWithRelationTopLevel(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {TagGroupFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupControllerApi
     */
    public tagGroupControllerFindById(id: string, filter?: TagGroupFilter, options?: any) {
        return TagGroupControllerApiFp(this.configuration).tagGroupControllerFindById(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupControllerApi
     */
    public tagGroupControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return TagGroupControllerApiFp(this.configuration).tagGroupControllerReplaceById(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupControllerApi
     */
    public tagGroupControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return TagGroupControllerApiFp(this.configuration).tagGroupControllerUpdateAll(where, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupControllerApi
     */
    public tagGroupControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return TagGroupControllerApiFp(this.configuration).tagGroupControllerUpdateById(id, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * TagGroupTagControllerApi - axios parameter creator
 * @export
 */
export const TagGroupTagControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagControllerCreate(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagGroupTagControllerCreate.');
            }
            const localVarPath = `/tag-groups/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagControllerDelete(id: string, where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagGroupTagControllerDelete.');
            }
            const localVarPath = `/tag-groups/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagControllerFind(id: string, filter?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagGroupTagControllerFind.');
            }
            const localVarPath = `/tag-groups/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagGroupTagControllerPatch.');
            }
            const localVarPath = `/tag-groups/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagGroupTagControllerApi - functional programming interface
 * @export
 */
export const TagGroupTagControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag> {
            const localVarAxiosArgs = TagGroupTagControllerApiAxiosParamCreator(configuration).tagGroupTagControllerCreate(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagControllerDelete(id: string, where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = TagGroupTagControllerApiAxiosParamCreator(configuration).tagGroupTagControllerDelete(id, where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagControllerFind(id: string, filter?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>> {
            const localVarAxiosArgs = TagGroupTagControllerApiAxiosParamCreator(configuration).tagGroupTagControllerFind(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = TagGroupTagControllerApiAxiosParamCreator(configuration).tagGroupTagControllerPatch(id, where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagGroupTagControllerApi - factory interface
 * @export
 */
export const TagGroupTagControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<Tag> {
            return TagGroupTagControllerApiFp(configuration).tagGroupTagControllerCreate(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagControllerDelete(id: string, where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return TagGroupTagControllerApiFp(configuration).tagGroupTagControllerDelete(id, where, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagControllerFind(id: string, filter?: { [key: string]: object; }, options?: any): AxiosPromise<Array<Tag>> {
            return TagGroupTagControllerApiFp(configuration).tagGroupTagControllerFind(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return TagGroupTagControllerApiFp(configuration).tagGroupTagControllerPatch(id, where, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * TagGroupTagControllerApi - object-oriented interface
 * @export
 * @class TagGroupTagControllerApi
 * @extends {BaseAPI}
 */
export class TagGroupTagControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupTagControllerApi
     */
    public tagGroupTagControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return TagGroupTagControllerApiFp(this.configuration).tagGroupTagControllerCreate(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupTagControllerApi
     */
    public tagGroupTagControllerDelete(id: string, where?: { [key: string]: object; }, options?: any) {
        return TagGroupTagControllerApiFp(this.configuration).tagGroupTagControllerDelete(id, where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupTagControllerApi
     */
    public tagGroupTagControllerFind(id: string, filter?: { [key: string]: object; }, options?: any) {
        return TagGroupTagControllerApiFp(this.configuration).tagGroupTagControllerFind(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupTagControllerApi
     */
    public tagGroupTagControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return TagGroupTagControllerApiFp(this.configuration).tagGroupTagControllerPatch(id, where, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * TagGroupTagGroupControllerApi - axios parameter creator
 * @export
 */
export const TagGroupTagGroupControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagGroupControllerCreate(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagGroupTagGroupControllerCreate.');
            }
            const localVarPath = `/tag-groups/{id}/tag-groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagGroupControllerDelete(id: string, where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagGroupTagGroupControllerDelete.');
            }
            const localVarPath = `/tag-groups/{id}/tag-groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagGroupControllerFind(id: string, filter?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagGroupTagGroupControllerFind.');
            }
            const localVarPath = `/tag-groups/{id}/tag-groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagGroupControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagGroupTagGroupControllerPatch.');
            }
            const localVarPath = `/tag-groups/{id}/tag-groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagGroupTagGroupControllerApi - functional programming interface
 * @export
 */
export const TagGroupTagGroupControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagGroupControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagGroup> {
            const localVarAxiosArgs = TagGroupTagGroupControllerApiAxiosParamCreator(configuration).tagGroupTagGroupControllerCreate(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagGroupControllerDelete(id: string, where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = TagGroupTagGroupControllerApiAxiosParamCreator(configuration).tagGroupTagGroupControllerDelete(id, where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagGroupControllerFind(id: string, filter?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagGroup>> {
            const localVarAxiosArgs = TagGroupTagGroupControllerApiAxiosParamCreator(configuration).tagGroupTagGroupControllerFind(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagGroupControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = TagGroupTagGroupControllerApiAxiosParamCreator(configuration).tagGroupTagGroupControllerPatch(id, where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagGroupTagGroupControllerApi - factory interface
 * @export
 */
export const TagGroupTagGroupControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagGroupControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<TagGroup> {
            return TagGroupTagGroupControllerApiFp(configuration).tagGroupTagGroupControllerCreate(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagGroupControllerDelete(id: string, where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return TagGroupTagGroupControllerApiFp(configuration).tagGroupTagGroupControllerDelete(id, where, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagGroupControllerFind(id: string, filter?: { [key: string]: object; }, options?: any): AxiosPromise<Array<TagGroup>> {
            return TagGroupTagGroupControllerApiFp(configuration).tagGroupTagGroupControllerFind(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagGroupTagGroupControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return TagGroupTagGroupControllerApiFp(configuration).tagGroupTagGroupControllerPatch(id, where, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * TagGroupTagGroupControllerApi - object-oriented interface
 * @export
 * @class TagGroupTagGroupControllerApi
 * @extends {BaseAPI}
 */
export class TagGroupTagGroupControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupTagGroupControllerApi
     */
    public tagGroupTagGroupControllerCreate(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return TagGroupTagGroupControllerApiFp(this.configuration).tagGroupTagGroupControllerCreate(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupTagGroupControllerApi
     */
    public tagGroupTagGroupControllerDelete(id: string, where?: { [key: string]: object; }, options?: any) {
        return TagGroupTagGroupControllerApiFp(this.configuration).tagGroupTagGroupControllerDelete(id, where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupTagGroupControllerApi
     */
    public tagGroupTagGroupControllerFind(id: string, filter?: { [key: string]: object; }, options?: any) {
        return TagGroupTagGroupControllerApiFp(this.configuration).tagGroupTagGroupControllerFind(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagGroupTagGroupControllerApi
     */
    public tagGroupTagGroupControllerPatch(id: string, where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return TagGroupTagGroupControllerApiFp(this.configuration).tagGroupTagGroupControllerPatch(id, where, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * TagTagGroupControllerApi - axios parameter creator
 * @export
 */
export const TagTagGroupControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTagGroupControllerGetTagGroup(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagTagGroupControllerGetTagGroup.');
            }
            const localVarPath = `/tags/{id}/tag-group`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagTagGroupControllerApi - functional programming interface
 * @export
 */
export const TagTagGroupControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTagGroupControllerGetTagGroup(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagGroup>> {
            const localVarAxiosArgs = TagTagGroupControllerApiAxiosParamCreator(configuration).tagTagGroupControllerGetTagGroup(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagTagGroupControllerApi - factory interface
 * @export
 */
export const TagTagGroupControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTagGroupControllerGetTagGroup(id: string, options?: any): AxiosPromise<Array<TagGroup>> {
            return TagTagGroupControllerApiFp(configuration).tagTagGroupControllerGetTagGroup(id, options)(axios, basePath);
        },
    };
};

/**
 * TagTagGroupControllerApi - object-oriented interface
 * @export
 * @class TagTagGroupControllerApi
 * @extends {BaseAPI}
 */
export class TagTagGroupControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagTagGroupControllerApi
     */
    public tagTagGroupControllerGetTagGroup(id: string, options?: any) {
        return TagTagGroupControllerApiFp(this.configuration).tagTagGroupControllerGetTagGroup(id, options)(this.axios, this.basePath);
    }

}


/**
 * TagTagTypeControllerApi - axios parameter creator
 * @export
 */
export const TagTagTypeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTagTypeControllerGetTagType(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagTagTypeControllerGetTagType.');
            }
            const localVarPath = `/tags/{id}/tag-type`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagTagTypeControllerApi - functional programming interface
 * @export
 */
export const TagTagTypeControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTagTypeControllerGetTagType(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagType>> {
            const localVarAxiosArgs = TagTagTypeControllerApiAxiosParamCreator(configuration).tagTagTypeControllerGetTagType(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagTagTypeControllerApi - factory interface
 * @export
 */
export const TagTagTypeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTagTypeControllerGetTagType(id: string, options?: any): AxiosPromise<Array<TagType>> {
            return TagTagTypeControllerApiFp(configuration).tagTagTypeControllerGetTagType(id, options)(axios, basePath);
        },
    };
};

/**
 * TagTagTypeControllerApi - object-oriented interface
 * @export
 * @class TagTagTypeControllerApi
 * @extends {BaseAPI}
 */
export class TagTagTypeControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagTagTypeControllerApi
     */
    public tagTagTypeControllerGetTagType(id: string, options?: any) {
        return TagTagTypeControllerApiFp(this.configuration).tagTagTypeControllerGetTagType(id, options)(this.axios, this.basePath);
    }

}


/**
 * TagTypeControllerApi - axios parameter creator
 * @export
 */
export const TagTypeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerCount(where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/tag-types/count`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerCreate(requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/tag-types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerDeleteAll(options: any = {}): RequestArgs {
            const localVarPath = `/tag-types/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerDeleteById(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagTypeControllerDeleteById.');
            }
            const localVarPath = `/tag-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TagTypeFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerFind(filter?: TagTypeFilter, options: any = {}): RequestArgs {
            const localVarPath = `/tag-types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {TagTypeFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerFindById(id: string, filter?: TagTypeFilter, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagTypeControllerFindById.');
            }
            const localVarPath = `/tag-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagTypeControllerReplaceById.');
            }
            const localVarPath = `/tag-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/tag-types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagTypeControllerUpdateById.');
            }
            const localVarPath = `/tag-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagTypeControllerApi - functional programming interface
 * @export
 */
export const TagTypeControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerCount(where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = TagTypeControllerApiAxiosParamCreator(configuration).tagTypeControllerCount(where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerCreate(requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagType> {
            const localVarAxiosArgs = TagTypeControllerApiAxiosParamCreator(configuration).tagTypeControllerCreate(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerDeleteAll(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TagTypeControllerApiAxiosParamCreator(configuration).tagTypeControllerDeleteAll(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerDeleteById(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TagTypeControllerApiAxiosParamCreator(configuration).tagTypeControllerDeleteById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {TagTypeFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerFind(filter?: TagTypeFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagTypeWithRelations>> {
            const localVarAxiosArgs = TagTypeControllerApiAxiosParamCreator(configuration).tagTypeControllerFind(filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {TagTypeFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerFindById(id: string, filter?: TagTypeFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagTypeWithRelations> {
            const localVarAxiosArgs = TagTypeControllerApiAxiosParamCreator(configuration).tagTypeControllerFindById(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TagTypeControllerApiAxiosParamCreator(configuration).tagTypeControllerReplaceById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = TagTypeControllerApiAxiosParamCreator(configuration).tagTypeControllerUpdateAll(where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TagTypeControllerApiAxiosParamCreator(configuration).tagTypeControllerUpdateById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagTypeControllerApi - factory interface
 * @export
 */
export const TagTypeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerCount(where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return TagTypeControllerApiFp(configuration).tagTypeControllerCount(where, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerCreate(requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<TagType> {
            return TagTypeControllerApiFp(configuration).tagTypeControllerCreate(requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerDeleteAll(options?: any): AxiosPromise<void> {
            return TagTypeControllerApiFp(configuration).tagTypeControllerDeleteAll(options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerDeleteById(id: string, options?: any): AxiosPromise<void> {
            return TagTypeControllerApiFp(configuration).tagTypeControllerDeleteById(id, options)(axios, basePath);
        },
        /**
         * 
         * @param {TagTypeFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerFind(filter?: TagTypeFilter, options?: any): AxiosPromise<Array<TagTypeWithRelations>> {
            return TagTypeControllerApiFp(configuration).tagTypeControllerFind(filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {TagTypeFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerFindById(id: string, filter?: TagTypeFilter, options?: any): AxiosPromise<TagTypeWithRelations> {
            return TagTypeControllerApiFp(configuration).tagTypeControllerFindById(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return TagTypeControllerApiFp(configuration).tagTypeControllerReplaceById(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return TagTypeControllerApiFp(configuration).tagTypeControllerUpdateAll(where, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagTypeControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return TagTypeControllerApiFp(configuration).tagTypeControllerUpdateById(id, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * TagTypeControllerApi - object-oriented interface
 * @export
 * @class TagTypeControllerApi
 * @extends {BaseAPI}
 */
export class TagTypeControllerApi extends BaseAPI {
    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagTypeControllerApi
     */
    public tagTypeControllerCount(where?: { [key: string]: object; }, options?: any) {
        return TagTypeControllerApiFp(this.configuration).tagTypeControllerCount(where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagTypeControllerApi
     */
    public tagTypeControllerCreate(requestBody?: { [key: string]: object; }, options?: any) {
        return TagTypeControllerApiFp(this.configuration).tagTypeControllerCreate(requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagTypeControllerApi
     */
    public tagTypeControllerDeleteAll(options?: any) {
        return TagTypeControllerApiFp(this.configuration).tagTypeControllerDeleteAll(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagTypeControllerApi
     */
    public tagTypeControllerDeleteById(id: string, options?: any) {
        return TagTypeControllerApiFp(this.configuration).tagTypeControllerDeleteById(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {TagTypeFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagTypeControllerApi
     */
    public tagTypeControllerFind(filter?: TagTypeFilter, options?: any) {
        return TagTypeControllerApiFp(this.configuration).tagTypeControllerFind(filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {TagTypeFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagTypeControllerApi
     */
    public tagTypeControllerFindById(id: string, filter?: TagTypeFilter, options?: any) {
        return TagTypeControllerApiFp(this.configuration).tagTypeControllerFindById(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagTypeControllerApi
     */
    public tagTypeControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return TagTypeControllerApiFp(this.configuration).tagTypeControllerReplaceById(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagTypeControllerApi
     */
    public tagTypeControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return TagTypeControllerApiFp(this.configuration).tagTypeControllerUpdateAll(where, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagTypeControllerApi
     */
    public tagTypeControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return TagTypeControllerApiFp(this.configuration).tagTypeControllerUpdateById(id, requestBody, options)(this.axios, this.basePath);
    }

}


/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCount(where?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/users/count`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate(requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerDeleteById(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userControllerDeleteById.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFind(filter?: UserFilter, options: any = {}): RequestArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UserFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindById(id: string, filter?: UserFilter, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userControllerFindById.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerLogin(requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/users/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userControllerReplaceById.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userControllerUpdateById.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCount(where?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = UserControllerApiAxiosParamCreator(configuration).userControllerCount(where, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate(requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UserControllerApiAxiosParamCreator(configuration).userControllerCreate(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerDeleteById(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = UserControllerApiAxiosParamCreator(configuration).userControllerDeleteById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UserFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFind(filter?: UserFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserWithRelations>> {
            const localVarAxiosArgs = UserControllerApiAxiosParamCreator(configuration).userControllerFind(filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UserFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindById(id: string, filter?: UserFilter, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWithRelations> {
            const localVarAxiosArgs = UserControllerApiAxiosParamCreator(configuration).userControllerFindById(id, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerLogin(requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200> {
            const localVarAxiosArgs = UserControllerApiAxiosParamCreator(configuration).userControllerLogin(requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = UserControllerApiAxiosParamCreator(configuration).userControllerReplaceById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoopbackCount> {
            const localVarAxiosArgs = UserControllerApiAxiosParamCreator(configuration).userControllerUpdateAll(where, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = UserControllerApiAxiosParamCreator(configuration).userControllerUpdateById(id, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCount(where?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return UserControllerApiFp(configuration).userControllerCount(where, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate(requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<User> {
            return UserControllerApiFp(configuration).userControllerCreate(requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerDeleteById(id: string, options?: any): AxiosPromise<void> {
            return UserControllerApiFp(configuration).userControllerDeleteById(id, options)(axios, basePath);
        },
        /**
         * 
         * @param {UserFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFind(filter?: UserFilter, options?: any): AxiosPromise<Array<UserWithRelations>> {
            return UserControllerApiFp(configuration).userControllerFind(filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UserFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFindById(id: string, filter?: UserFilter, options?: any): AxiosPromise<UserWithRelations> {
            return UserControllerApiFp(configuration).userControllerFindById(id, filter, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerLogin(requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<InlineResponse200> {
            return UserControllerApiFp(configuration).userControllerLogin(requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return UserControllerApiFp(configuration).userControllerReplaceById(id, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} [where] 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<LoopbackCount> {
            return UserControllerApiFp(configuration).userControllerUpdateAll(where, requestBody, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {{ [key: string]: object; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return UserControllerApiFp(configuration).userControllerUpdateById(id, requestBody, options)(axios, basePath);
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public userControllerCount(where?: { [key: string]: object; }, options?: any) {
        return UserControllerApiFp(this.configuration).userControllerCount(where, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public userControllerCreate(requestBody?: { [key: string]: object; }, options?: any) {
        return UserControllerApiFp(this.configuration).userControllerCreate(requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public userControllerDeleteById(id: string, options?: any) {
        return UserControllerApiFp(this.configuration).userControllerDeleteById(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {UserFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public userControllerFind(filter?: UserFilter, options?: any) {
        return UserControllerApiFp(this.configuration).userControllerFind(filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {UserFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public userControllerFindById(id: string, filter?: UserFilter, options?: any) {
        return UserControllerApiFp(this.configuration).userControllerFindById(id, filter, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public userControllerLogin(requestBody?: { [key: string]: object; }, options?: any) {
        return UserControllerApiFp(this.configuration).userControllerLogin(requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public userControllerReplaceById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return UserControllerApiFp(this.configuration).userControllerReplaceById(id, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: object; }} [where] 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public userControllerUpdateAll(where?: { [key: string]: object; }, requestBody?: { [key: string]: object; }, options?: any) {
        return UserControllerApiFp(this.configuration).userControllerUpdateAll(where, requestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {{ [key: string]: object; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public userControllerUpdateById(id: string, requestBody?: { [key: string]: object; }, options?: any) {
        return UserControllerApiFp(this.configuration).userControllerUpdateById(id, requestBody, options)(this.axios, this.basePath);
    }

}


